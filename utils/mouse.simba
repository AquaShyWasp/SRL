(*
Mouse
=======
Methods to interact with the mouse.
*)

{$DEFINE SRL_MOUSE_INCLUDED}
{$IFNDEF SRL_UTILS}
  {$I SRL/utils.simba}
{$ENDIF}

{.$DEFINE SRL_DEBUG_MOUSE} // Enable me to record mouse path + clicks. Will be displayed when script terminates.

const
  MOUSE_MOVE = -1;

(*
EMouseDistribution
~~~~~~~~~~~~~~~~~~

The available distributions used to generate a point in a box.

- **MOUSE_DISTRIBUTION_RANDOM**: Completely random point
- **MOUSE_DISTRIBUTION_GAUSS**:  Weighted towards the center
- **MOUSE_DISTRIBUTION_SKEWED**: Weighted torwards current mouse position
- **MOUSE_DISTRIBUTION_ROWP**:   Weighted torwards current mouse position but more "rounded" compared to **MOUSE_DISTRIBUTION_SKEWED**

**MOUSE_DISTRIBUTION_DEFAULT** will use **Mouse.Distribution** by default is **MOUSE_DISTRIBUTION_ROWP**

*)
type
  EMouseDistribution = (
    MOUSE_DISTRIBUTION_DEFAULT,
    MOUSE_DISTRIBUTION_RANDOM,
    MOUSE_DISTRIBUTION_GAUSS,
    MOUSE_DISTRIBUTION_SKEWED,
    MOUSE_DISTRIBUTION_ROWP
  );

(*
TMouse
~~~~~~

- Mouse.Speed: Overall speed of the mouse
- Mouse.MissChance: Chance % to "Miss" the destination
- Mouse.Distribution: Default mouse distribution to use when clicking boxes

**Example**

  // These are the default values that can be changed
  Mouse.Speed := 13;
  Mouse.MissChance := 10; // 10% chance each time the mouse is moved
  Mouse.Distribution := MOUSE_DISTRIBUTION_ROWP;
*)
type
  PMouse = ^TMouse;

  TMouseMovingEvent = procedure(Sender: PMouse; var X, Y: Double; var Done: Boolean);
  TMouseTeleportEvent = procedure(Sender: PMouse; X, Y: Int32);

  TMouse = record(TSRLBaseRecord)
    Speed: Double;
    Gravity, Wind: Double;
    Distribution: EMouseDistribution;
    MissChance: Double;
    OnMoving: TMouseMovingEvent;
    OnTeleport: TMouseTeleportEvent;

    {$IFDEF SRL_DEBUG_MOUSE}
    DebugBitmap: TMufasaBitmap;
    {$ENDIF}
  end;

{$IFDEF SRL_DEBUG_MOUSE}
procedure TMouse._Debug;
begin
  if (Self.DebugBitmap = nil) then
    Exit;

  ShowBitmap(DebugBitmap);

  DebugBitmap.Free();
end;

procedure TMouse._DebugCallback(Sender: PMouse; X, Y: Int32); static;
begin
  if (Sender^.DebugBitmap = nil) then
  begin
    Sender^.DebugBitmap := GetMufasaBitmap(BitmapFromClient(GetClientBounds()));
    Sender^.DebugBitmap.DrawClear(0);

    AddOnTerminate(@Sender^._Debug);
  end;

  if Sender^.DebugBitmap.PointInBitmap(X, Y) and (Sender^.DebugBitmap.GetPixel(X, Y) <> $0000FF) then
    Sender^.DebugBitmap.SetPixel(X, Y, $00FF00);
end;
{$ENDIF}

procedure TMouse.Setup;
begin
  Self.Name := 'Mouse';
  Self.Speed := 13;
  Self.Gravity := 20;
  Self.Wind := 15;
  Self.MissChance := 10;
  Self.Distribution := MOUSE_DISTRIBUTION_ROWP;

  {$IFDEF SRL_DEBUG_MOUSE}
  Self.OnTeleport := @Self._DebugCallback;
  {$ENDIF}
end;

(*
Mouse.Teleport
~~~~~~~~~~~~~~
.. pascal:: procedure TMouse.Teleport(X, Y: Int32);

Teleport the mouse to the desired X, Y coordinates.
*)
procedure TMouse.Teleport(X, Y: Int32); overload;
begin
  if (@Self.OnTeleport <> nil) then
    Self.OnTeleport(@Self, X, Y);

  MoveMouse(X, Y);
end;

(*
Mouse.Teleport
~~~~~~~~~~~~~~
.. pascal:: procedure TMouse.Teleport(P: TPoint);

Teleport the mouse to the desired point.
*)
procedure TMouse.Teleport(P: TPoint); overload;
begin
  Self.Teleport(P.X, P.Y);
end;

(*
Mouse.Position
~~~~~~~~~~~~~~
.. pascal:: function TMouse.Position: TPoint;

Returns the mouse current position.
*)
function TMouse.Position: TPoint;
begin
  GetMousePos(Result.X, Result.Y);
end;

(*
Mouse.Hold
~~~~~~~~~~
.. pascal:: procedure TMouse.Hold(Button: Int32);

Holds the desired mouse button down. The button will continue to be held down until `Mouse.Release` is called.

Button can be either:
 - MOUSE_LEFT
 - MOUSE_RIGHT
 - MOUSE_SCROLL
 - MOUSE_EXTRA_1
 - MOUSE_EXTRA_2

**Example**

  Mouse.Hold(MOUSE_LEFT); // The mouse is now pressing down left click.
*)
procedure TMouse.Hold(Button: Int32);
begin
  with Self.Position() do
    HoldMouse(X, Y, Button);
end;

(*
Mouse.Release
~~~~~~~~~~~~~
.. pascal:: procedure TMouse.Release(Button: Int32);

Releases the desired mouse button which has been previously held.

Button can be either:
 - MOUSE_LEFT
 - MOUSE_RIGHT
 - MOUSE_SCROLL
 - MOUSE_EXTRA_1
 - MOUSE_EXTRA_2

**Example**

  Mouse.Release(MOUSE_LEFT); // The mouse is no longer pressing left click.
*)
procedure TMouse.Release(Button: Int32);
begin
  with Self.Position() do
    ReleaseMouse(X, Y, Button);
end;

(*
Mouse.WindMouse
~~~~~~~~~~~~~~~
.. pascal:: procedure TMouse.Release(Button: Int32);

The internal algorithm used by `Mouse.Move` to move the mouse in a human'ish way.

Credit: BenLand100 (https://github.com/BenLand100/SMART/blob/master/src/EventNazi.java#L201)
*)
procedure TMouse.WindMouse(xs, ys, xe, ye, gravity, wind, minWait, maxWait, maxStep, targetArea: Double);
const
  SQRT_3: Double := sqrt(3);
  SQRT_5: Double := sqrt(5);
var
  x, y: Double;
  veloX, veloY, windX, windY, veloMag, randomDist, step, idle: Double;
  traveledDistance, remainingDistance: Double;
  Countdown: TCountDown;
  Finished: Boolean;
begin
  Countdown.Init(15000);

  x := xs;
  y := ys;

  while True do
  begin
    if Countdown.IsFinished() then
      Self.Fatal('Something went wrong. Mouse movement did not complete in 15 seconds.');

    if (@Self.OnMoving <> nil) then
    begin
      Self.OnMoving(@Self, xe, ye, Finished);
      if Finished then
        Exit;
    end;

    traveledDistance := Hypot(x - xs, y - ys);
    remainingDistance := Hypot(x - xe, y - ye);
    if (remainingDistance <= 1) then
      Break;

    wind := Min(wind, remainingDistance);
    windX := windX / SQRT_3 + (Random(Round(wind) * 2 + 1) - wind) / SQRT_5;
    windY := windY / SQRT_3 + (Random(Round(wind) * 2 + 1) - wind) / SQRT_5;

    if (remainingDistance < targetArea) then
      step := (remainingDistance / 2) + (Random() * 6 - 3)
    else
    if (traveledDistance < targetArea) then
    begin
      if (traveledDistance < 3) then
        traveledDistance := 10 * Random();

      step := traveledDistance * (1 + Random() * 3);
    end else
      step := maxStep;

    step := Min(step, maxStep);
    if (step < 3) then
      step := 3 + (Random() * 3);

    veloX := veloX + windX;
    veloY := veloY + windY;
    veloX := veloX + gravity * (xe - x) / remainingDistance;
    veloY := veloY + gravity * (ye - y) / remainingDistance;

    if (Hypot(veloX, veloY) > step) then
    begin
      randomDist := step / 3.0 + (step / 2 * Random());

      veloMag := sqrt(veloX * veloX + veloY * veloY);
      veloX := (veloX / veloMag) * randomDist;
      veloY := (veloY / veloMag) * randomDist;
    end;

    idle := (maxWait - minWait) * (Hypot(veloX, veloY) / step) + minWait;

    x := x + veloX;
    y := y + veloY;

    Self.Teleport(Round(x), Round(y));

    Wait(Round(idle));
  end;

  Self.Teleport(Round(xe), Round(ye));
end;

(*
Mouse.Move
~~~~~~~~~~
.. pascal:: procedure TMouse.Move(P: TPoint);

Moves the mouse to the desired point.

**Example**

  var P: TPoint;

  P.X := 50;
  P.Y := 50;

  Mouse.Move(P);

  WriteLn(Mouse.Position()); // 50, 50
*)
procedure TMouse.Move(P: TPoint); overload;
var
  RandSpeed: Double;
begin
  RandSpeed := ((Random() * Self.Speed) / 1.5 + Self.Speed) / 10.0;

  Self.WindMouse(
    Self.Position.X, Self.Position.Y, P.X, P.Y,
    Self.Gravity, Self.Wind,
    10 / RandSpeed, 20 / RandSpeed, (3 * RandSpeed) ** 2, 50 * RandSpeed
  );
end;

(*
Mouse.Move
~~~~~~~~~~
.. pascal:: procedure TMouse.Move(P: TPoint);

Moves the mouse to the desired X,Y coordinate.

**Example**

  Mouse.Move(50, 50);

  WriteLn(Mouse.Position()); // 50, 50
*)
procedure TMouse.Move(X, Y: Int32); overload;
begin
  Self.Move(Point(X, Y));
end;

(*
Mouse.Move
~~~~~~~~~~
.. pascal:: procedure TMouse.Move(Box: TBox; ForcedMove: Boolean = False; Distribution: EMouseDistribution = MOUSE_DISTRIBUTION_DEFAULT);

Moves the mouse to a random point in the box.

- **ForcedMove** determines if the mouse should be moved if already in the box. By default this is **False**
- **Distribution** determines the method to generate a random point. By default this uses **Mouse.Distribution**

**Example**

  var B: TBox;

  B.X1 := 100;
  B.Y1 := 100;
  B.X2 := 200;
  B.Y2 := 200;

  Mouse.Move(B);

  WriteLn(Mouse.Position()); // The mouse is now randomly within 100,100,200,200
*)
procedure TMouse.Move(Box: TBox; ForcedMove: Boolean = False; Distribution: EMouseDistribution = MOUSE_DISTRIBUTION_DEFAULT); overload;
begin
  if Box.Contains(Self.Position()) and (not ForcedMove) then
    Exit;

  if Distribution = MOUSE_DISTRIBUTION_DEFAULT then
    Distribution := Self.Distribution;

  case Distribution of
    MOUSE_DISTRIBUTION_RANDOM: Self.Move(Random(Box.X1, Box.X2), Random(Box.Y1, Box.Y2));
    MOUSE_DISTRIBUTION_GAUSS:  Self.Move(SRL.RandomPoint(Box));
    MOUSE_DISTRIBUTION_SKEWED: Self.Move(SRL.RandomPointEx(Self.Position(), Box));
    MOUSE_DISTRIBUTION_ROWP:   Self.Move(SRL.Rowp(Self.Position(), Box));
  end;
end;

(*
Mouse.Move
~~~~~~~~~~
.. pascal:: procedure TMouse.Move(Circle: TCircle; ForcedMove: Boolean = False);

Moves the mouse to a random point in an circle.

- **ForcedMove** determines if the mouse should be moved if already in the circle. By default this is False.

**Example**

  var C: TCircle;

  C.X := 100;
  C.Y := 100;
  C.Radius := 25;

  Mouse.Move(C);

  WriteLn(Mouse.Position()); // The mouse is now randomly within 100,100 with a radius of 25.
*)
procedure TMouse.Move(Circle: TCircle; ForcedMove: Boolean = False); overload;
var
  P: TPoint;
begin
  if Circle.Contains(Self.Position()) and (not ForcedMove) then
    Exit;

  Self.Move(SRL.RandomPoint(Circle.Mean(), Circle.Radius));
end;

(*
Mouse.Move
~~~~~~~~~~
.. pascal:: procedure TMouse.Move(Rect: TRectangle; ForcedMove: Boolean = False);

Moves the mouse to a random point in an rectangle.

- **ForcedMove** determines if the mouse should be moved if already in the rectangle. By default this is False.
*)
procedure TMouse.Move(Rect: TRectangle; ForcedMove: Boolean = False); overload;
begin
  if Rect.Contains(Self.Position()) and (not ForcedMove) then
    Exit;

  Self.Move(SRL.RandomPoint(Rect));
end;

(*
Mouse.Click
~~~~~~~~~~~
.. pascal:: procedure TMouse.Click(Button: Int32);

Clicks the mouse with the desired button at the current mouse position.

Button can be either:
 - MOUSE_LEFT
 - MOUSE_RIGHT
 - MOUSE_SCROLL
 - MOUSE_EXTRA_1
 - MOUSE_EXTRA_2

**Example**

  WriteLn('Left clicking at: ', Mouse.Position());

  Mouse.Click(MOUSE_LEFT);
*)
procedure TMouse.Click(Button: Int32);
begin
  Self.Hold(Button);
  Wait(SRL.TruncatedGauss(30, 300));
  Self.Release(Button);

  {$IFDEF SRL_DEBUG_MOUSE}
  with Self.Position() do
    Self.DebugBitmap.SetPixel(X, Y, $0000FF);
  {$ENDIF}
end;

procedure TMouse.Click(P: TPoint; Button: Int32); overload;
begin
  Self.Move(P.X, P.Y);
  Self.Click(Button);
end;

procedure TMouse.Click(X, Y: Int32; Button: Int32); overload;
begin
  Self.Click(Point(X, Y), Button);
end;

procedure TMouse.Click(Box: TBox; Button: Int32; ForcedMove: Boolean = False; Distribution: EMouseDistribution = MOUSE_DISTRIBUTION_DEFAULT); overload;
begin
  Self.Move(Box, ForcedMove, Distribution);
  Self.Click(Button);
end;

procedure TMouse.Click(Circle: TCircle; Button: Int32; ForcedMove: Boolean = False); overload;
begin
  Self.Move(Circle, ForcedMove);
  Self.Click(Button);
end;

procedure TMouse.Click(Rect: TRectangle; Button: Int32; ForcedMove: Boolean = False); overload;
begin
  Self.Move(Rect, ForcedMove);
  Self.Click(Button);
end;

(*
Mouse.Miss
~~~~~~~~~~
.. pascal:: procedure TMouse.Miss(P: TPoint);

"Misses" the target point **P**. Will stop somewhere along the path or overshoot.

This can automatically be called depending on Mouse.MissChance.
*)
procedure TMouse.Miss(P: TPoint);
var
  MissPoint: TPoint;
  Range: Int32;
  Miss: Double;
  Temp: Double := Self.MissChance;
begin
  Self.MissChance := 0; // prevent recursion

  try
    Range := Trunc(Power(Self.Position().DistanceTo(P), 0.80)); // how much possible range to miss
    Miss := SRL.SkewedRand(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination (P).

    MissPoint.X := Trunc((1-Miss)*Self.Position().X + Miss*P.X);
    MissPoint.Y := Trunc((1-Miss)*Self.Position().Y + Miss*P.Y);

    MissPoint.X += SRL.NormalRange(-Range, Range);
    MissPoint.Y += SRL.NormalRange(-Range, Range);

    Self.Move(MissPoint);

    if SRL.Dice(10) then
      Wait(0, 3000, wdLeft);
  finally
    Self.MissChance := Temp;
  end;
end;

procedure TMouse.DragTo(P: TPoint; Button: Int32 = mouse_Left);
begin
  Self.Hold(Button);
  Wait(80, 120);
  Self.Move(P);
  Wait(80, 120);
  Self.Release(Button);
end;

procedure TMouse.Scroll(Scrolls: Int32; Down: Boolean);
var
  i, step, k: Int32 = 1;
  P: TPoint;
begin
  P := Self.Position();
  step := Round(SRL.GaussRand(6.0,0.6));
  for i := 1 to Scrolls do
  begin
    if Down then
      ScrollMouse(P.X, P.Y, 1)
    else
      ScrollMouse(P.X, P.Y, -1);

    if k mod step = 0 then
    begin
      step := Round(SRL.GaussRand(6.0,0.6));
      Wait(215, 410);
      k := 0;
    end else
      Wait(25, 46);

    Inc(k);
  end;
end;

procedure TMouse.Scroll(Target: TPoint; Scrolls: Int32; Down: Boolean); overload;
begin
  Self.Move(Target);
  Self.Scroll(Scrolls, Down);
end;

procedure TMouse.Scroll(Box: TBox; Scrolls: Int32; Down: Boolean); overload;
begin
  Self.Move(Box);
  Self.Scroll(Scrolls, Down);
end;

var
  Mouse: TMouse;

begin
  Mouse.Setup();
end;

