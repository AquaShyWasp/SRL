(*
Walker
======
*)

{$DEFINE SRL_WALKER_INCLUDED}
{$DEFINE SRL_DEBUG_WALKER_CACHE}

{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{$I webgraph.simba}
{$I world.graph}
{$I zeah.graph}

type
  TRSWalkerCache = record
    World: TMufasaBitmap;
    WorldSample: TMufasaBitmap;
    Speed: Int32;

    Rotation: Single;
    Position: TPoint;
    Radius: Int32;

    LastUsed: UInt64;
  end;

  TRSWalker = record(TSRLBaseRecord)
    Cache: array of TRSWalkerCache;
    CacheSize: Int32;
    CacheRadius: Int32;

    Rotation: Single;

    World: TMufasaBitmap;
    WorldSample: TMufasaBitmap;
    Web: TWebGraph;

    EnableRunAtEnergy: Int32;

    Speed: Int32;
    Similarity: Single;
    ScreenWalk: Boolean;
  end;

function TRSWalker.FindMap(Map: String): String; static;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);

  if FileExists(Map) then
    Exit(Map);

  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY}, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

function TRSWalker.LoadMap(Path: String): TMufasaBitmap; static;
var
  Cache: String;
begin
  Result.Init(Client.GetMBitmaps());

  if ExtractFileExt(Path) <> '.bmp' then
  begin
    Cache := ExtractFileDir(Path) + DirectorySeparator + SHA1File(Path) + '.bmp';

    // Save as bitmap for much faster loading
    if not FileExists(Cache) then
    begin
      Result.LoadFromFile(Path);
      Result.SaveToFile(Cache);
    end;

    if FileExists(Cache) then
      Path := Cache;
  end;

  Result.LoadFromFile(Path);
end;

procedure TRSWalker.Free;
begin
  Self.WorldSample.Free();
  Self.World.Free();
end;

procedure TRSWalker.Setup(Map: String; Speed: Int32 = 10);
var
  Path: String;
begin
  Self.Name := 'Walker';

  Path := Self.FindMap(Map);
  if (Path = '') then
    Self.Fatal('Unable to find map: ' + Map);

  Self.Speed := Speed;
  Self.CacheSize := 3;
  Self.CacheRadius := 200;

  case Map.Lower() of
    'world': Self.Web  := WorldWeb;
    'zeah':  Self.Web  := ZeahWeb;
  end;

  Self.WorldSample.Init(Client.GetMBitmaps());

  Self.World := Self.LoadMap(Path);
  Self.World.Downsample(Self.Speed, Self.WorldSample);
end;

procedure TRSWalker.ClearDots(Bitmap: TMufasaBitmap);
const
  Template: TPointArray =
    [        [1, 0], [2, 0],
     [0, 1], [1, 1], [2, 1], [3, 1],
     [0, 2], [1, 2], [2, 2], [3, 2],
     [0, 3], [1, 3], [2, 3], [3, 3],
             [1, 4], [2, 4]
    ];
var
  Dots: TPointArray;
  ATPA: T2DPointArray;
  Corners: array[0..3] of TPoint;
  I, J: Int32;
  Colors: TIntegerArray;
begin
  Dots := Minimap.GetDotsBitmap(Bitmap, [MINIMAP_DOT_NPC, MINIMAP_DOT_ITEM, MINIMAP_DOT_PLAYER]);

  SetLength(ATPA, Length(Dots));

  for I := 0 to High(Dots) do
  begin
    ATPA[I] := Template.Offset(Dots[I]);
	
    Bitmap.DrawTPA(ATPA[I], clFuchsia);
  end;

  for I := 0 to High(Dots) do
  begin
    Corners[0] := [ATPA[I][0].X - 1, ATPA[I][0].Y];
    Corners[1] := [ATPA[I][1].X + 1, ATPA[I][1].Y];
    Corners[2] := [ATPA[I][14].X - 1, ATPA[I][14].Y];
    Corners[3] := [ATPA[I][15].X + 1, ATPA[I][15].Y];

    Colors := Bitmap.GetPixels(Corners);
    for J := 0 to High(Colors) do
      if Colors[J] <> clFuchsia then
      begin
        Bitmap.DrawTPA(ATPA[I], Colors[j]);

        Break;
      end;
  end;
end;

function TRSWalker.GetMinimap(out CenterOffset: TPoint): TMufasaBitmap;
var
  Bounds: TBox;
  Raw, Templ: TMufasaBitmap;
  Poly: TPointArray;
  Angle: Double;
  B: TBox;
  I: Int32;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  Column: TBox;
begin
  Angle := Minimap.GetCompassAngle(False);
  Bounds := Minimap.Bounds();

  Poly := TPAFromPolygon(Minimap.GetPolygon());
  Poly := Poly.Invert(Bounds);
  Poly := Poly.Offset([-Bounds.X1, -Bounds.Y1]);

  Result.Init(Client.GetMBitmaps());

  Raw := GetMufasaBitmap(BitmapFromClient(Bounds));
  ClearDots(Raw);
  Raw.RotateBitmapEx(Angle, False, True, Result);

  Templ.Init();
  Templ.SetSize(Raw.GetWidth(), Raw.GetHeight());
  Templ.DrawClear(clFuchsia);

  Raw.DrawTPA(Poly, clFuchsia);
  Raw.RotateBitmapEx(Angle, False, False, Templ);

  // Expand top left until box hits fushsia
  B.X1 := (Raw.GetWidth() div 2) - 30;
  B.Y1 := (Raw.GetHeight() div 2) - 30;

  while (Templ.GetPixel(B.X1, B.Y1) <> clFuchsia) do
  begin
    B.X1 -= 1;
    B.Y1 -= 1;
  end;

  // Expand bottom right until box hits fushsia
  B.X2 := (Raw.GetWidth() div 2) + 30;
  B.Y2 := (Raw.GetHeight() div 2) + 30;

  while (Templ.GetPixel(B.X2, B.Y2) <> clFuchsia) do
  begin
    B.X2 += 1;
    B.Y2 += 1;
  end;

  // Expand all corners until corner hits fushsia
  // Top Left
  while Templ.GetPixel(B.X1, B.Y1) <> clFuchsia do
  begin
    B.X1 -= 1;
    B.Y1 -= 1;
  end;

  // Top Right
  while Templ.GetPixel(B.X2, B.Y1) <> clFuchsia do
  begin
    B.X2 += 1;
    B.Y1 -= 1;
  end;

  // Bottom Left
  while Templ.GetPixel(B.X1, B.Y2) <> clFuchsia do
  begin
    B.X1 -= 1;
    B.Y2 += 1;
  end;

  // Bottom Right
  while Templ.GetPixel(B.X2, B.Y2) <> clFuchsia do
  begin
    B.X2 += 1;
    B.Y2 += 1;
  end;

  B := B.Expand(5);

  Templ.FindColors(TPA, clFuchsia);

  // Fix corners, replace fuchica with nearest color in columns
  // Top corners
  ATPA := FindTPAColumns(TPA.FilterBox(B.Partition(2, 1)[0]));
  for I := 0 to High(ATPA) do
  begin
    Column := GetTPABounds(ATPA[I]);

    Result.Rectangle(Column, Templ.GetPixel(Column.X1, Column.Y2 + 1));
  end;

  // Bottom corners
  ATPA := FindTPAColumns(TPA.FilterBox(B.Partition(2, 1)[1]));
  for I := 0 to High(ATPA) do
  begin
    Column := GetTPABounds(ATPA[I]);

    Result.Rectangle(Column, Templ.GetPixel(Column.X1, Column.Y1 - 1));
  end;

  Result.Crop(B.X1 + 1, B.Y1 + 1, B.X2 - 1, B.Y2 - 1);

  Templ.Free();
  Raw.Free();

  CenterOffset.X := Bounds.Middle.X - (Bounds.X1 + B.Middle.X);
  CenterOffset.Y := Bounds.Middle.Y - (Bounds.Y1 + B.Middle.Y);
end;

function TRSWalker.FindImageNear(p:TPoint; Large, Sub: TMufasaBitmap; Area:Int32; Offsets: TSingleArray; out match: Single; out Offset: Single): TPoint; static;
var
  W,H: Int32;
  Slice: TMufasaBitmap;
  B: TBox;
  Matrix: TSingleMatrix;
  tmp: TMufasaBitmap;
  Test: Single;
  Best: TPoint;
begin
  Match := 0;

  W := Large.GetWidth - 1;
  H := Large.GetHeight - 1;

  B := [p.x, p.y, p.x + Sub.GetWidth(), p.y + Sub.GetHeight()];
  B := [B.x1-Area, B.y1-Area, B.x2+Area, B.y2+Area];
  B := [max(0,B.x1),max(0,B.y1),min(W,B.x2),min(H,B.y2)];

  Slice := Large.Copy(B.x1, B.y1, B.x2, B.y2);
  Slice.SetSize(Max(Slice.GetWidth(), Sub.GetWidth()), Max(Slice.GetHeight(), Sub.GetHeight()));

  client.getMBitmaps.AddBMP(Slice);
  Tmp.init(Client.getMBitmaps());

  for Test in Offsets do
  begin
    Slice.RotateBitmapEx(Radians(Test), False, True, tmp);
    Matrix := Tmp.MatchTemplate(Sub, TM_CCOEFF_NORMED);
    Best := Matrix.ArgMax;
    if Matrix[Best.Y, Best.X] > Match then
    begin
      Match := Matrix[Best.Y, Best.X];
      Result := [Best.x-Area+p.x, Best.y-Area+p.y];
      Offset := Test;
    end;
  end;

  Slice.Free();
  Tmp.Free();
end;

function TRSWalkerCache.GetMyPos(Minimap: TMufasaBitmap; MinimapSample: TMufasaBitmap; MinimapOffset: TPoint; out Similarity: Single): TPoint;
var
  P: TPoint;
  Sample: TMufasaBitmap;
  Matrix: TSingleMatrix;
  _: Single;
  B: TBox;
begin
  P.X := Self.Position.X div Self.Speed;
  P.Y := Self.Position.Y div Self.Speed;

  // Get scaled world map around last known position
  B.X1 := Max(P.X - (Self.Radius div Self.Speed), 0);
  B.Y1 := Max(P.Y - (Self.Radius div Self.Speed), 0);
  B.X2 := Min(P.X + (Self.Radius div Self.Speed), WorldSample.GetWidth()  - 1);
  B.Y2 := Min(P.Y + (Self.Radius div Self.Speed), WorldSample.GetHeight() - 1);

  Sample := WorldSample.Copy(B.X1, B.Y1, B.X2, B.Y2);

  // Find scaled minimap on scaled world map around last known position
  Matrix := Sample.MatchTemplate(MinimapSample, TM_CCOEFF_NORMED);

  Result.X := B.X1 * Self.Speed;
  Result.Y := B.Y1 * Self.Speed;
  Result   += Matrix.ArgMax() * Self.Speed;

  // Now search the world map around our match without scaling
  Result   := TRSWalker.FindImageNear(Result, Self.World, Minimap, 20, [Self.Rotation], Similarity, _);
  Result   += MinimapOffset;
  Result.X += Minimap.GetWidth() div 2;
  Result.Y += Minimap.GetHeight() div 2;

  Sample.Free();
end;

procedure TRSWalker.AddCache(Position: TPoint);
var
  Cache: TRSWalkerCache;
  I, J: Int32;
begin
  if Self.CacheSize = 0 then
  begin
    if Length(Self.Cache) > 0 then
      SetLength(Self.Cache, 0);

    Exit;
  end;

  {$IFDEF SRL_DEBUG_WALKER_CACHE}
  Self.Debug('New cache: ' + ToString(Position));
  {$ENDIF}

  Cache.Position := Position;
  Cache.Radius := Self.CacheRadius;
  Cache.Speed := Self.Speed;
  Cache.World := Self.World;
  Cache.WorldSample := Self.WorldSample;
  Cache.Rotation := Self.Rotation;
  Cache.LastUsed := GetTickCount();

  if Length(Self.Cache) = Self.CacheSize then
  begin
    for I := 0 to High(Self.Cache) do
      for J := 0 to High(Self.Cache) do
        if Self.Cache[I].LastUsed < Self.Cache[J].LastUsed then
          Swap(Self.Cache[I], Self.Cache[J]);

    {$IFDEF SRL_DEBUG_WALKER_CACHE}
    Self.Debug('Evicting cache: ' + ToString(Self.Cache[0].Position));
    {$ENDIF}

    Self.Cache[0] := Cache;
  end else
    Self.Cache := Self.Cache + Cache;
end;

function TRSWalker.GetMyPos: TPoint;
var
  MinimapSample, MinimapBitmap: TMufasaBitmap;
  Matrix: TSingleMatrix;
  MinimapOffset: TPoint;
  I: Int32;
  TPA: TPointArray;
  Match, Rotation: Single;
  P: TPoint;
  T: UInt64;
begin
  T := GetTickCount();

  MinimapSample.Init(Client.GetMBitmaps());

  MinimapBitmap := GetMinimap(MinimapOffset);
  MinimapBitmap.Downsample(Self.Speed, MinimapSample);

  try
    Self.Similarity := 0;

    // Try cache first
    for I := 0 to High(Self.Cache) do
    begin
      P := Self.Cache[I].GetMyPos(MinimapBitmap, MinimapSample, MinimapOffset, Match);

      if Match > Self.Similarity then
      begin
        Self.Similarity := Match;
        Self.Rotation := Rotation;

        Result := P;
      end;
    end;

    // Good cache hit?
    if Self.Similarity > 0.40 then
      Exit;

    {$IFDEF SRL_DEBUG_WALKER_CACHE}
    if Length(Self.Cache) > 0 then
      Self.Debug('No cache hit: ' + ToString(Self.Similarity));
    {$ENDIF}

    Matrix := WorldSample.MatchTemplate(MinimapSample, TM_CCOEFF_NORMED);

    // Inspect 3 best hits on the scaled map without scaling and pick the best
    TPA := Matrix.Indices(Matrix.Max() - 0.05, __GT__);
    TPA := TPA.Split(5).Means();

    for I := 0 to Min(High(TPA), 2) do
    begin
      P   := Self.FindImageNear(TPA[I] * Self.Speed, Self.World, MinimapBitmap, 20, [-2, 0, 2], Match, Rotation);
      P   += MinimapOffset;
      P.X += MinimapBitmap.getWidth() div 2;
      P.Y += MinimapBitmap.getHeight() div 2;

      if Match > Self.Similarity then
      begin
        Self.Similarity := Match;
        Self.Rotation := Rotation;

        Result := P;
      end;
    end;

    // Add to cache if good hit
    if Self.Similarity > 0.40 then
      AddCache(Result);

    {$IFDEF SRL_DEBUG_WALKER_CACHE}
    Self.Debug('Full scan: ' + ToString(Self.Similarity));
    {$ENDIF}
  finally
    if MinimapBitmap <> nil then
      MinimapBitmap.Free();
    if MinimapSample <> nil then
      MinimapSample.Free();
  end;
end;

function TRSWalker.WorldToMM(PlayerPoint, WorldPoint: TPoint; Radians: Double): TPoint; overload;
begin
  Result := WorldPoint - PlayerPoint + Minimap.Center;
  Result := Result.Rotate(Radians, Minimap.Center);
end;

function TRSWalker.WorldToMM(WorldPoint: TPoint): TPoint; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), WorldPoint, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WalkStep(PlayerPoint, WorldPoint: TPoint; ClickRandomness: Int32 = 0; WaitUntilDistance: Int32 = -1): Boolean; overload;
var
  MinimapPoint: TPoint;
  Countdown, Timeout: TCountDown;
  Position: record
    Current, Previous: TPoint;
  end;
  P: TPoint;
begin
  if not RSClient.IsLoggedIn() then
    Exit(False);

  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(MinimapPoint)) then
    Exit(False);
  if (Minimap.Center.DistanceTo(MinimapPoint) <= 4) then
    Exit(True);

  if (WaitUntilDistance = -1) then
  begin
    WaitUntilDistance := Distance(Minimap.Center, MinimapPoint);

    // 50% chance for clicking again near instantly.
    // 35% change for value weighted towards mean
    // 15% chance for wait until player has nearly stopped moving.

    if Random() < 0.50 then
      WaitUntilDistance := Round(SRL.TruncatedGauss(WaitUntilDistance - 10, WaitUntilDistance + 20))
    else
    if Random() < 0.15 then
      WaitUntilDistance := Round(SRL.TruncatedGauss(0, 15))
    else
      WaitUntilDistance := Round(SRL.SkewedRand(WaitUntilDistance div 2, 0, WaitUntilDistance));
  end;

  if (WaitUntilDistance < 2) then
    WaitUntilDistance := 2;

  if Self.ScreenWalk then
  begin
    Mouse.Move(Minimap.PointToMsRect(MinimapPoint));

    if MainScreen.IsUpText('Walk here', Random(100)) then
      Mouse.Click(MOUSE_LEFT)
    else
      ChooseOption.Select('Walk here');
  end else
  begin
    repeat
      P := [Random(MinimapPoint.X - ClickRandomness, MinimapPoint.X + ClickRandomness),
            Random(MinimapPoint.Y - ClickRandomness, MinimapPoint.Y + ClickRandomness)];
    until Minimap.IsPointOn(P);

    Mouse.Click(P, MOUSE_LEFT);
  end;

  Timeout.Init(Round(SRL.TruncatedGauss(20000, 25000)));

  Countdown.Init(Round(SRL.TruncatedGauss(500, 1500)));
  Countdown.Timeout := GetTickCount() + Round(SRL.TruncatedGauss(2500, 3500));

  Position.Previous := PlayerPoint;
  Position.Current := PlayerPoint;

  // Break from the loop if:
  // - Haven't moved for 2.5 seconds
  // - Been walking for over 20 seconds
  // - Within `WaitUntilDistance` to the destination
  repeat
    if not RSClient.IsLoggedIn() then
      Exit(False);

    if (not Minimap.IsRunEnabled()) and (Minimap.GetRunEnergy() > Self.EnableRunAtEnergy) then
    begin
      Minimap.EnableRun();

      Self.EnableRunAtEnergy := Round(SRL.SkewedRand(35, 0, 100));
    end;

    Position.Previous := Position.Current;
    Position.Current := Self.GetMyPos();
    if Position.Current <> Position.Previous then
      Countdown.Restart();

    Wait(100);
  until Timeout.IsFinished() or Countdown.IsFinished() or (Position.Current.DistanceTo(WorldPoint) <= WaitUntilDistance);

  Exit(True);
end;

function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; overload;
var
  MinimapPoint: TPoint;
  R: TRectangle;
  B: TBox;
begin
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  case Self.ScreenWalk of
    True:
      begin
        R := Minimap.PointToMSRect(MinimapPoint, Angle);

        if InterfaceArea.Bounds().Contains(R) then
        begin
          B := R.Bounds;
          B.LimitTo(InterfaceArea.Bounds());

          // Client doesn't render far tiles when zoomed out
          if (CountColor($000000, B) = 0) then
            Exit(True);
        end;
      end;

    False:
      begin
        Result := Minimap.IsPointOn(MinimapPoint);
      end;
  end;
end;

function TRSWalker.GetFurthestWalkable(PlayerPoint: TPoint; Path: TPointArray; var Index: Int32): Boolean;
var
  Angle: Double;
  i, Dist, Nearest, Previous: Int32;
begin
  Previous := Index;

  Nearest := $FFFFFF;

  for i := 0 to High(Path) do
  begin
    Dist := Distance(Path[i].X, Path[i].Y, PlayerPoint.X, PlayerPoint.Y);

    if Dist < Nearest then
    begin
      Nearest := Dist;
      Index := i;
    end;
  end;

  Angle := Minimap.GetCompassAngle(False);

  for Index := Index to High(Path) - 1 do
  begin
    // Some randomness so we don't always click the furthest point
    if (Random() < 0.10) and (Index > Previous) and (PlayerPoint.DistanceTo(Path[Index]) > 20) then
      Break;

    if (not Self.IsWalkable(Path[Index + 1], PlayerPoint, Angle)) then
      Break;
  end;

  Result := Index > Previous;
end;

function TRSWalker.WalkPath(Path: TPointArray; ClickRandomness: Int32 = 2; FinalCorrection: Boolean = False): Boolean;

  function BuildPath(TPA: TPointArray; minStep,maxStep:Int32): TPointArray; static; overload;
  var
    i,j: Int32;
    tmp: TPointArray;
  begin
    for i:=1 to High(TPA) do
    begin
      tmp := TPAFromLine(TPA[i-1].x,TPA[i-1].y, TPA[i].x,TPA[i].y);
      j := 0;
      while j < High(tmp) do
      begin
        Result += tmp[j];
        Inc(j, Random(minStep, maxStep));
      end;
    end;
    Result += TPA[High(TPA)];
  end;

var
  PlayerPoint: TPoint;
  Index: Int32;
  Attempts: Int32;
begin
  Path := BuildPath([Self.GetMyPos()] + Path, 4, 12);

  while RSClient.IsLoggedIn() do
  begin
    PlayerPoint := Self.GetMyPos();

    if Self.GetFurthestWalkable(PlayerPoint, Path, Index) then
      Attempts := 0
    else
    begin
      Attempts := Attempts + 1;
      if (Attempts > 20) then
        Exit(False);

      if (Attempts mod 2 = 0) then
        Minimap.WaitFlag();
    end;

    if Index = High(Path) then
    begin
      if Self.WalkStep(PlayerPoint, Path[Index], 0, 0) then
      begin
        if FinalCorrection then
          Self.WalkStep(Self.GetMyPos(), Path[Index], 0, 0);

        Exit(True);
      end;
    end else
      Self.WalkStep(PlayerPoint, Path[Index], ClickRandomness);
  end;
end;

function TRSWalker.WalkBlind(Destination: TPoint; ClickRandomness: Int32 = 4; FinalCorrection: Boolean = False): Boolean;
begin
  Result := WalkPath([Destination], ClickRandomness, FinalCorrection);
end;

function TRSWalker.WebWalk(Destination: TPoint; ClickRnd:Int32=4; PathRnd:Double=0; FinalCorrection:Boolean = False): Boolean;
var
  path: TPointArray;
begin
  if (PathRnd > 1) or (PathRnd < 0) then
    RaiseException(erException, 'TRSWalker.WebWalk -> PathRnd should be in the range `0..1` where `1` is max');

  path   := Self.Web.PathBetween(Self.GetMyPos, Destination, PathRnd);
  Result := Self.WalkPath(path, ClickRnd, FinalCorrection);
end;

function TRSWalker.WebWalk(Destination: String; ClickRnd:Int32=4; PathRnd:Double=0; FinalCorrection:Boolean=False): Boolean; overload;
var
  dstNode: Int32;
begin
  dstNode := Self.Web.FindNode(Destination);
  if dstNode = -1 then
    Self.Web.InvalidNode(Destination);

  Result := Self.WebWalk(Self.Web.Nodes[dstNode], ClickRnd, PathRnd, FinalCorrection);
end;

procedure TRSWalker.DebugPosition;
var
  X1, Y1, X2, Y2, X, Y: Int32;
  Bitmap, WorldBitmap, MinimapBitmap: TMufasaBitmap;
  Time: Double;
  Position: TPoint;
  _: TPoint;
  Lines: TStringArray;
begin
  Time := PerformanceTimer();
  Position := Self.GetMyPos();
  Time := PerformanceTimer() - Time;

  X1 := Max(0, Position.X - 200);
  Y1 := Max(0, Position.Y - 200);
  X2 := Min(X1 + 400, Self.World.GetWidth()  - 1);
  Y2 := Min(Y1 + 400, Self.World.GetHeight() - 1);

  X := Position.X - X1;
  Y := Position.Y - Y1;

  WorldBitmap := Self.World.Copy(X1, Y1, X2, Y2);
  WorldBitmap.LineTo(Point(0, Y), Point(X2 - X1, Y), $00FF00);
  WorldBitmap.LineTo(Point(X, 0), Point(X, Y2 - Y1), $00FF00);
  WorldBitmap.DrawBox(Box(X - 2, Y - 2, X + 2, Y + 2), False, $FFFFFF);

  MinimapBitmap := GetMinimap(_);

  Bitmap.Init();
  Bitmap.SetSize(560, 420);
  Bitmap.DrawClear($403027);

  Lines := [
    '('      + ToStr(Position.X, ', ', Position.Y) + ')',
    'Acc: '  + ToStr(Round(Self.Similarity, 3)),
    'Time: ' + ToStr(Round(Time)) + ' ms'
  ];

  Bitmap.DrawSystemText(Lines[0], 'Consolas', 12, [420, 20 + MinimapBitmap.GetHeight()], False, $FFFFFF);
  Bitmap.DrawSystemText(Lines[1], 'Consolas', 12, [420, 370], False, $FFFFFF);
  Bitmap.DrawSystemText(Lines[2], 'Consolas', 12, [420, 390], False, $FFFFFF);

  WorldBitmap.DrawTransparent(10, 10, Bitmap);
  WorldBitmap.Free();

  MinimapBitmap.DrawTransparent(420, 10, Bitmap);
  MinimapBitmap.Free();

  Bitmap.Debug();
  Bitmap.Free();
end;

(*
  Returns the tile position on the mainscreen as a rectangle
*)
function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height:Double=0; Offx,Offy:Double=0): TRectangle;
var
  angle: Double;
begin
  Loc   := Minimap.Center + (Loc - Me);
  angle := Minimap.GetCompassAngle(False);
  Loc   := Loc.Rotate(angle, Minimap.Center);
  Result := Minimap.VecToMSRect(Vec3(Loc.x - offx, Loc.y - offy, Height), angle);
end;

(*
  Same as the above, only you dont have to pass "MyPos" to it.
*)
function TRSWalker.GetTileMS(Loc: TPoint; Height:Double=0; Offx,Offy:Double=0): TRectangle;
begin
  Result := GetTileMSEx(Self.GetMyPos(), Loc, Height, Offx, Offy);
end;

function TRSWalker.MSToWorldEx(Me, Loc: TPoint; Height: Int32 = 0; Accuracy: Double = 0.2): TPoint;
begin
  Result := Me + (MainScreen.PointToMM(Loc, Height, Accuracy).ToPoint() - Minimap.Center);
  Result := Result.Rotate(-Minimap.GetCompassAngle(False), Me);
end;

function TRSWalker.MSToWorld(Loc: TPoint; Height: Int32=0; Accuracy:Double=0.2): TPoint;
begin
  Result := Self.MSToWorldEx(Self.GetMyPos(), Loc, Height, Accuracy);
end;
