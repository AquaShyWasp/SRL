{$DEFINE SRL_ITEMFINDER_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSItemFinder = record
    ItemNames: TStringList;
    ItemImages: array of TMufasaBitmap;
    Similarity: Single;
  end;

var
  ItemFinder: TRSItemFinder;

const
  ITEM_FINDER_NAME_FILE    = {$macro CURRENT_DIRECTORY} + '/items';
  ITEM_FINDER_IMAGES_ZIP   = {$macro CURRENT_DIRECTORY} + '/images.zip';
  ITEM_FINDER_IMAGES_PATH  = {$macro CURRENT_DIRECTORY} + '/images/';

  ITEM_FINDER_SHADOW_COLOR = $202030;
  ITEM_FINDER_BORDER_COLOR = $10000;

  ITEM_FINDER_YELLOW_STACK = $00FFFF;
  ITEM_FINDER_WHITE_STACK  = $FFFFFF;
  ITEM_FINDER_GREEN_STACK  = $80FF00;

procedure TRSItemFinder.Free;
var
  i: Int32;
begin
  if Self.ItemNames <> nil then
    Self.ItemNames.Free();

  for i := 0 to High(Self.ItemImages) do
    Self.ItemImages[i].Free();
end;

procedure TRSItemFinder.Setup;
begin
  Self.Similarity := 0.999;

  AddOnTerminate(@Self.Free);
end;

function TRSItemFinder.GetItemID(Identifer: String): Int32;
begin
  if not Identifer.IsDigit() then
  begin
    if Self.ItemNames = nil then
    begin
      Self.ItemNames.Init();
      Self.ItemNames.LoadFromFile(ITEM_FINDER_NAME_FILE);
    end;

    if Self.ItemNames.IndexOfName(Identifer) = -1 then
      raise 'Unknown item: ' + Identifer;

    Identifer := Self.ItemNames.GetValues(Identifer);
  end;

  Result := StrToInt(Identifer);
end;

function TRSItemFinder.GetTemporaryImage(Identifer: String): TMufasaBitmap;
var
  ID: String;
  i: Int32;
  Image: TMufasaBitmap;
begin
  for i := 0 to High(ItemImages) do
    if (Self.ItemImages[i].GetName() = Identifer) then
      Exit(Self.ItemImages[i].Copy());

  ID := ToString(Self.GetItemID(Identifer)) + '.png';
  if not FileExists(ITEM_FINDER_IMAGES_PATH + ID) then
    UnZipOneFile(ITEM_FINDER_IMAGES_ZIP, ID, ITEM_FINDER_IMAGES_PATH);
  if not FileExists(ITEM_FINDER_IMAGES_PATH + ID) then
    raise 'Unable to load image: ' + ID;

  Image.Init(Client.GetMBitmaps());
  Image.LoadFromFile(ITEM_FINDER_IMAGES_PATH + ID);
  Image.SetName(Identifer);
  Image.ReplaceColor(ITEM_FINDER_SHADOW_COLOR, 0);

  Self.ItemImages := Self.ItemImages + Image;

  Result := Image.Copy();
end;

function TRSItemFinder.Find(Identifer: String; Slots: TBoxArray): TIntegerArray;

  function GetAlignmentPoint(Image: TMufasaBitmap): TPoint;
  var
    TPA: TPointArray;
  begin
    if Image.FindColors(TPA, ITEM_FINDER_BORDER_COLOR) then
    begin
      TPA.SortByY(False);

      Result := TPA[0];
    end;
  end;

  function AlignTemplateToImage(Image, Template: TMufasaBitmap): TMufasaBitmap;
  var
    ImageAligment, TemplateAlignment: TPoint;
  begin
    ImageAligment := GetAlignmentPoint(Image);
    TemplateAlignment := GetAlignmentPoint(Template);
    if (ImageAligment = []) or (TemplateAlignment = []) then
      Exit(nil);

    Result.Init(Client.GetMBitmaps());
    Result.SetSize(Image.GetWidth(), Image.GetHeight());

    Template.DrawTransparent(
      Max(0, ImageAligment.X - TemplateAlignment.X),
      Max(0, ImageAligment.Y - TemplateAlignment.Y), Result
    );

    Template.Free();
  end;

  procedure Clear(Image, Template: TMufasaBitmap; TPA: TPointArray; Offset: TPoint = []);
  begin
    Image.DrawTPA(TPA, $000000);
    Template.DrawTPA(TPA, $000000);

    if Offset <> [] then
    begin
      OffsetTPA(TPA, Offset);

      Image.DrawTPA(TPA, $000000);
      Template.DrawTPA(TPA, $000000);
    end;
  end;

var
  Image, Templ: TMufasaBitmap;
  TPA: TPointArray;
  Slot: Int32;
begin
  for Slot := 0 to High(Slots) do
  begin
    Image := Self.GetTemporaryImage(Identifer);

    Templ.FromClient(Slots[Slot]);
    Templ.FindColors(TPA, ITEM_FINDER_BORDER_COLOR);

    if Length(TPA) > 0 then
    begin
      with TPA.Bounds() do
        Templ.Crop(X1, Y1, X2, Y2);

      // Align both images using the same bottom point
      Templ := AlignTemplateToImage(Image, Templ);

      if Templ <> nil then
      begin
        // Clear stack: Find on template, and clear on both images.
        if Templ.FindColors(TPA, ITEM_FINDER_YELLOW_STACK) then Clear(Image, Templ, TPA, [1, 1]);
        if Templ.FindColors(TPA, ITEM_FINDER_WHITE_STACK) then Clear(Image, Templ, TPA, [1, 1]);
        if Templ.FindColors(TPA, ITEM_FINDER_GREEN_STACK) then Clear(Image, Templ, TPA, [1, 1]);

        // Clear background: Since images are aligned we know the background points from our database image.
        if Image.FindColors(TPA, $000000) then Clear(Image, Templ, TPA);

        if Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0] > Self.Similarity then
          Result := Result + Slot;
      end;
    end;

    Image.Free();
    Image := nil;
    Templ.Free();
    Templ := nil;
  end;
end;

function TRSInventory.FindAll(Identifers: TStringArray): TIntegerArray; override;
var
  Identifer: String;
begin
  if BankScreen.IsOpen or Self.Open() then
    for Identifer in Identifers do
      Result += ItemFinder.Find(Identifer, Self.GetSlotBoxes());
end;

function TRSInventory.FindAll(Identifer: String): TIntegerArray; override;
begin
  if BankScreen.IsOpen or Self.Open() then
    Result := Self.FindAll([Identifer]);
end;

function TRSInventory.Find(Identifers: TStringArray): Int32; override;
var
  Identifer: String;
  Matches: TIntegerArray;
begin
  for Identifer in Identifers do
  begin
    Matches := Self.FindAll(Identifer);
    if Length(Matches) > 0 then
      Exit(Matches[0]);
  end;

  Exit(-1);
end;

function TRSInventory.Find(Identifer: String): Int32; override;
begin
  Result := Self.Find([Identifer]);
end;

function TRSInventory.Count(Identifers: TStringArray): Int32; override;
var
  Identifer: String;
begin
  if (BankScreen.IsOpen or Self.Open()) then
  begin
    for Identifer in Identifers do
      Result += Length(Self.FindAll(Identifer));
  end;
end;

function TRSInventory.Count(Identifer: String): Int32; override;
begin
  Result := Self.Count([Identifer]);
end;

function TRSInventory.CountStack(Identifer: String): Int32; override;
var
  Slot: Int32;
begin
  Slot := Self.Find(Identifer);
  if (Slot > -1) then
    Result := SRL.GetItemAmount(Self.GetSlotBox(Slot));
end;

function TRSInventory.Click(Identifers: TStringArray; Option: String = ''): Boolean; override;
var
  Slot: Int32;
begin
  Slot := Self.Find(Identifers);

  if (Slot > -1) then
  begin
    Mouse.Move(Self.GetSlotBox(Slot));

    if (Option = '') then
    begin
      Mouse.Click(MOUSE_LEFT);

      Exit(True);
    end else
    begin
      if ChooseOption.Select(Option) then
        Exit(False);
    end;
  end;
end;

function TRSInventory.Click(Identifer: String; Option: String = ''): Boolean; override;
begin
  Result := Self.Click([Identifer], Option);
end;

function TRSBankScreen.WithdrawItem(Identifier: String; Amount: Int32; Noted: Boolean): Boolean; override;
var
  Items: TBoxArray;
  Matches: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  Items := Self.FindItems();

  Matches := ItemFinder.Find(Identifier, Items);
  if Length(Matches) > 0 then
    Result := Self.WithdrawItem(Items[Matches[0]], Amount, Noted);
end;

function TRSBankScreen.WithdrawQuantity(Identifier: String; Amount: String; Noted: Boolean): Boolean; override;
var
  Items: TBoxArray;
  Matches: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  Items := Self.FindItems();

  Matches := ItemFinder.Find(Identifier, Items);
  if Length(Matches) > 0 then
    Result := Self.WithdrawQuantity(Items[Matches[0]], Amount, Noted);
end;

function TRSBankScreen.Count(Identifer: String): Int32; override;
begin
  if not Self.IsOpen() then
    Exit;

  Result := Length(ItemFinder.Find(Identifer, Self.FindItems()));
end;

function TRSBankScreen.CountStack(Identifer: String): Int32; override;
var
  Items: TBoxArray;
  Matches: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  Items := Self.FindItems();

  Matches := ItemFinder.Find(Identifer, Items);
  if Length(Matches) > 0 then
    Result := SRL.GetItemAmount(Items[Matches[0]]);
end;

begin
  ItemFinder.Setup();
end;
