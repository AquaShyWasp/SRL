(*
Item Finder
===========
*)

{$DEFINE SRL_ITEMFINDER_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSItem = type Variant;
  TRSItemArray = array of TRSItem;

  TRSItemFinder = record
    ItemNames: TStringList;
    ItemImages: array of TMufasaBitmap;
    
    Similarity: Single;
  end;

var
  ItemFinder: TRSItemFinder;

const
  ITEM_FINDER_NAME_FILE    = {$macro CURRENT_DIRECTORY} + '/item-names';
  ITEM_FINDER_IMAGES_ZIP   = {$macro CURRENT_DIRECTORY} + '/item-images.zip';
  ITEM_FINDER_IMAGES_PATH  = {$macro CURRENT_DIRECTORY} + '/images/';

  ITEM_FINDER_SHADOW_COLOR = $202030;
  ITEM_FINDER_BORDER_COLOR = $10000;

  ITEM_FINDER_YELLOW_STACK = $00FFFF;
  ITEM_FINDER_WHITE_STACK  = $FFFFFF;
  ITEM_FINDER_GREEN_STACK  = $80FF00;

procedure TRSItemFinder.Free;
var
  i: Int32;
begin
  Self.ItemNames.Free();
  for i := 0 to High(Self.ItemImages) do
    Self.ItemImages[i].Free();
end;

procedure TRSItemFinder.Setup;
begin
  CreateDirectory(ITEM_FINDER_IMAGES_PATH);

  Self.ItemNames.Init();
  Self.ItemNames.LoadFromFile(ITEM_FINDER_NAME_FILE);

  Self.Similarity := 0.999;

  AddOnTerminate(@Self.Free);
end;

procedure TRSItemFinder.AddItemName(Item, ID: String);
begin
  Self.ItemNames.SetValues(Item, ID);
end;

function TRSItemFinder.LoadItemImage(Item: String): TMufasaBitmap;
var
  Path, ID: String;
begin
  if not Item.IsDigit() then
  begin
    if Self.ItemNames.IndexOfName(Item) = -1 then
      raise 'Unknown item: ' + Item;
  
    ID := Self.ItemNames.GetValues(Item);
  end else
    ID := Item; 
    
  Path := ExpandFileName(ITEM_FINDER_IMAGES_PATH + ID + '.png');
  
  if not FileExists(Path) then
    UnZipOneFile(ITEM_FINDER_IMAGES_ZIP, ExtractFileName(Path), ITEM_FINDER_IMAGES_PATH);
  if not FileExists(Path) then
    raise 'Unknown item: ' + Item;

  Result.Init(Client.GetMBitmaps());
  Result.LoadFromFile(Path);
  Result.SetName(Item);
  Result.ReplaceColor(ITEM_FINDER_SHADOW_COLOR, 0);
end;

function TRSItemFinder.GetTemporaryImage(Item: TRSItem): TMufasaBitmap;
var
  I: Int32;
  Image: TMufasaBitmap;
begin
  Item := VarToStr(Item);
  
  for I := 0 to High(ItemImages) do
    if (Self.ItemImages[I].GetName() = Item) then
      Exit(Self.ItemImages[I].Copy());
  
  Self.ItemImages += Self.LoadItemImage(Item);
  
  Result := Self.ItemImages[High(Self.ItemImages)].Copy();
end;

function TRSItemFinder.Find(Identifer: TRSItem; Slots: TBoxArray; MaxToFind: Int32 = -1): TIntegerArray;

  function GetAlignmentPoint(Image: TMufasaBitmap): TPoint;
  var
    TPA: TPointArray;
  begin
    if Image.FindColors(TPA, ITEM_FINDER_BORDER_COLOR) then
    begin
      TPA.SortByY(False);

      Result := TPA[0];
    end;
  end;

  function AlignTemplateToImage(Image, Template: TMufasaBitmap): TMufasaBitmap;
  var
    ImageAligment, TemplateAlignment: TPoint;
  begin
    ImageAligment := GetAlignmentPoint(Image);
    TemplateAlignment := GetAlignmentPoint(Template);
    if (ImageAligment = []) or (TemplateAlignment = []) then
      Exit(nil);

    Result.Init(Client.GetMBitmaps());
    Result.SetSize(Image.GetWidth(), Image.GetHeight());

    Template.DrawTransparent(
      Max(0, ImageAligment.X - TemplateAlignment.X),
      Max(0, ImageAligment.Y - TemplateAlignment.Y), Result
    );

    Template.Free();
  end;

  procedure Clear(Image, Template: TMufasaBitmap; TPA: TPointArray; Offset: TPoint = []);
  begin
    Image.DrawTPA(TPA, $000000);
    Template.DrawTPA(TPA, $000000);

    if Offset <> [] then
    begin
      OffsetTPA(TPA, Offset);

      Image.DrawTPA(TPA, $000000);
      Template.DrawTPA(TPA, $000000);
    end;
  end;

var
  Image, Templ: TMufasaBitmap;
  TPA: TPointArray;
  Slot: Int32;
begin
  for Slot := 0 to High(Slots) do
  begin
    Image := Self.GetTemporaryImage(Identifer);

    Templ.FromClient(Slots[Slot]);
    Templ.FindColors(TPA, ITEM_FINDER_BORDER_COLOR);

    if Length(TPA) > 0 then
    begin
      with TPA.Bounds() do
        Templ.Crop(X1, Y1, X2, Y2);

      // Align both images using the same bottom point
      Templ := AlignTemplateToImage(Image, Templ);

      if Templ <> nil then
      begin
        // Clear stack: Find on template, and clear on both images.
        if Templ.FindColors(TPA, ITEM_FINDER_YELLOW_STACK) then Clear(Image, Templ, TPA, [1, 1]);
        if Templ.FindColors(TPA, ITEM_FINDER_WHITE_STACK)  then Clear(Image, Templ, TPA, [1, 1]);
        if Templ.FindColors(TPA, ITEM_FINDER_GREEN_STACK)  then Clear(Image, Templ, TPA, [1, 1]);

        // Clear black border
        if Templ.FindColors(TPA, ITEM_FINDER_BORDER_COLOR) then Clear(Image, Templ, TPA, []);

        // Clear background: Since images are aligned we know the background points from our database image.
        if Image.FindColors(TPA, $000000) then Clear(Image, Templ, TPA);

        //WriteLn Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0];
        //Image.SaveToFile('img.png');
        //Templ.SaveToFile('templ.png');
        //Halt;

        if Image.MatchTemplate(Templ, TM_CCORR_NORMED)[0][0] > Self.Similarity then
          Result := Result + Slot;
      end;
    end;

    Image.Free();
    Image := nil;
    Templ.Free();
    Templ := nil;
    
    if Length(Result) = MaxToFind then
      Exit;
  end;
end;

begin
  ItemFinder.Setup();
end;
