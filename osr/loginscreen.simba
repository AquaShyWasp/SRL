{$DEFINE SRL_LOGINSCREEN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSLoginScreen = type TRSInterface;

const
  LOGIN_MESSAGE_NONE = '';
  LOGIN_MESSAGE_CONNECTING = 'Connecting to server';
  LOGIN_MESSAGE_INVALID_CREDENTIALS = 'Invalid credentials';
  LOGIN_MESSAGE_NEED_SKILL_TOTAL = 'You need a skill total of';
  LOGIN_MESSAGE_INVALID_USER_PASS = 'Please enter your username/email address.';
  LOGIN_MESSAGE_ERROR_CONNECTING = 'Error connecting to server';
  LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT = 'Your account has not logged out';
  LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE = 'Login server offline';
  LOGIN_MESSAGE_ERROR_LOADING_PROFILE = 'Error loading your profile';
  LOGIN_MESSAGE_CONNECTION_TIMED_OUT = 'Connection timed out';
  LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED = 'Login limit exceeded';
  LOGIN_MESSAGE_WORLD_FULL = 'This world is full';
  LOGIN_MESSAGE_ACCOUNT_DISABLED = 'Your account has been disabled';
  LOGIN_MESSAGE_MEMBERS = 'You need a members account';
  LOGIN_MESSAGE_IN_MEMBERS_AREA = 'You are standing in a members-only area';
  LOGIN_MESSAGE_AUTHENTICATOR = 'Authenticator';

  LOGIN_MESSAGES = [
    LOGIN_MESSAGE_CONNECTING,
    LOGIN_MESSAGE_INVALID_CREDENTIALS,
    LOGIN_MESSAGE_NEED_SKILL_TOTAL,
    LOGIN_MESSAGE_INVALID_USER_PASS,
    LOGIN_MESSAGE_ERROR_CONNECTING,
    LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT,
    LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE,
    LOGIN_MESSAGE_ERROR_LOADING_PROFILE,
    LOGIN_MESSAGE_CONNECTION_TIMED_OUT,
    LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED,
    LOGIN_MESSAGE_WORLD_FULL,
    LOGIN_MESSAGE_ACCOUNT_DISABLED,
    LOGIN_MESSAGE_MEMBERS,
    LOGIN_MESSAGE_IN_MEMBERS_AREA
  ];
  
  LOGIN_DIALOG_OK = 'Ok';
  LOGIN_DIALOG_TRY_AGAIN = 'Try again';
  LOGIN_DIALOG_EXISTING_USER = 'Existing User';
  
  LOGIN_DIALOGS = [
    LOGIN_DIALOG_OK,
    LOGIN_DIALOG_TRY_AGAIN,
    LOGIN_DIALOG_EXISTING_USER
  ];

function TRSLoginScreen.FindText(Text: String; out B: TBox): Boolean; overload;
begin
  Result := (FindTextColor(Text, RS_FONT_BOLD_12,  $000000, 0, Self.Bounds, B) = 1) or
            (FindTextColor(Text, RS_FONT_BOLD_12,  $FFFFFF, 0, Self.Bounds, B) = 1) or
            (FindTextColor(Text, RS_FONT_BOLD_12,  $00FFFF, 0, Self.Bounds, B) = 1) or
            (FindTextColor(Text, RS_FONT_PLAIN_12, $FFFFFF, 0, Self.Bounds, B) = 1) or
            (FindTextColor(Text, RS_FONT_PLAIN_11, $FFFFFF, 0, Self.Bounds, B) = 1);
end;

function TRSLoginScreen.FindText(Text: String): Boolean; overload;
var
  _: TBox;
begin
  Result := FindText(Text, _);
end;  

function TRSLoginScreen.ClickText(Text: String): Boolean;
var
  B: TBox;
begin
  Result := FindText(Text, B);
  if Result then 
    Mouse.Click(B, MOUSE_LEFT);
end;

function TRSLoginScreen.IsOpen: Boolean;
begin
  Result := Self.FindText('Click to switch');
end;

function TRSLoginScreen.IsWorldSwitcherOpen: Boolean;
begin
  Result := Self.FindText('Cancel');
end;

function TRSLoginScreen.OpenWorldSwitcher: Boolean;
begin
  Result := ClickText('Click to switch') and WaitUntil(Self.IsWorldSwitcherOpen(), 500, 5000); 
end;

function TRSLoginScreen.CloseWorldSwitcher: Boolean;
begin
  Result := Self.IsOpen() or (Self.ClickText('Cancel') and WaitUntil(Self.IsOpen(), 100, 1000));
end;

function TRSLoginScreen.GetCurrentWorld: Int32;
var
  B: TBox;
begin
  if Self.CloseWorldSwitcher() and Self.FindText('Click to switch', B) then
  begin
    B.Y1 -= 25;
    
    Result := OCR.RecognizeNumber(B, [$FFFFFF], RS_FONTSET_BOLD_12); // ADD: RecognizeInt
  end;
end;

function TRSLoginScreen.SwitchToWorld(World: Int32): Boolean;
begin
  if Self.GetCurrentWorld() = World then
    Exit(True);

  if Self.OpenWorldSwitcher() then
  begin
    for 1 to 3 do // Three pages of worlds
    begin
      if Self.ClickText(ToString(World)) then
      begin
        Result := Self.GetCurrentWorld() = World;
        Exit;
      end;
      
      Keyboard.PressKey(VK_RIGHT);
      
      Wait(500, 5000, wdLeft);
    end;
  end;
end;

procedure TRSLoginScreen.HandleDialogs;
var
  I: Int32;
begin
  for I := 0 to High(LOGIN_DIALOGS) do
    if Self.ClickText(' ' + LOGIN_DIALOGS[I] + ' ') then
      Exit;
end;

function TRSLoginScreen.EnterField(Field, Details: String): Boolean;
var
  B: TBox;
begin
  if Self.FindText(Details + ' ') then
    Exit(True);
  
  if Self.FindText(Field, B) then
  begin
    B.X1 := B.X2;
    B.X2 := B.X1 + 250;

    // Move caret
    while not WaitUntil(SRL.CountColor($00FFFF, B) > 15, 100, SRL.TruncatedGauss(800, 1600)) do
    begin
      if not Self.IsOpen() then 
        Exit(False);
      
      Keyboard.PressKey(VK_TAB);
    end;
  
    // Erase field
    while SRL.CountColor($FFFFFF, B) > 0 do
      Keyboard.PressKey(VK_BACK);
    Keyboard.Send(Details);
    
    Wait(0, 1000, wdLeft);
    
    Result := True;
  end;
end;

function TRSLoginScreen.GetLoginMessage: String;
var
  I: Int32;
begin
  Result := LOGIN_MESSAGE_NONE;

  for I := 0 to High(LOGIN_MESSAGES) do
    if Self.FindText(LOGIN_MESSAGES[I]) then
    begin
      Result := LOGIN_MESSAGES[I];
      
      Exit;
    end;
end;

function TRSLoginScreen.HandleMessage(Message: String): Boolean;
begin
  Self.Debug('Handling login message: ' + Message);

  case Message of
    // Cannot recover
    LOGIN_MESSAGE_MEMBERS,
    LOGIN_MESSAGE_IN_MEMBERS_AREA,
    LOGIN_MESSAGE_NEED_SKILL_TOTAL,
    LOGIN_MESSAGE_ACCOUNT_DISABLED,
    LOGIN_MESSAGE_AUTHENTICATOR:
      Result := False;

    // Retry
    LOGIN_MESSAGE_INVALID_CREDENTIALS,
    LOGIN_MESSAGE_INVALID_USER_PASS:
      Result := True;

    // Retry after ~15 seconds
    LOGIN_MESSAGE_ERROR_CONNECTING,
    LOGIN_MESSAGE_ACCOUNT_NOT_LOGGED_OUT,
    LOGIN_MESSAGE_LOGIN_SERVER_OFFLINE,
    LOGIN_MESSAGE_ERROR_LOADING_PROFILE,
    LOGIN_MESSAGE_CONNECTION_TIMED_OUT,
    LOGIN_MESSAGE_LOGIN_LIMIT_EXCEEDED,
    LOGIN_MESSAGE_WORLD_FULL:
      begin
        Wait(10000, 20000);

        Result := True;
      end;

    // No handler
    else
      Self.Fatal('Unknown login message');
  end;
end;

function TRSLoginScreen.Login(User, Password: String): Boolean;
var
  Message: String;
  Attempts: Int32;
begin
  Self.Debug('Logging in player');

  if (User = '') or (Password = '') then
    Self.Fatal('Player has no username or password');

  while Self.IsOpen() and (Attempts < 10) do
  begin
    Self.Debug('Attempt: ' + ToString(Attempts));

    Self.HandleDialogs();
    Self.EnterField('Login:', User);
    Self.EnterField('Password:', Password);
    
    Keyboard.PressKey(VK_ENTER);

    while Self.IsOpen() and (Self.GetLoginMessage() in [LOGIN_MESSAGE_CONNECTING, LOGIN_MESSAGE_NONE]) do
      Wait(500);

    if Self.IsOpen() then
    begin
      Message := Self.GetLoginMessage();
      if not Self.HandleMessage(Message) then
        Exit(False);
    end;

    Inc(Attempts);
  end;

  if LobbyScreen.IsOpen(3000) then
    LobbyScreen.EnterGame();

  Result := RSClient.IsLoggedIn();
end;

procedure TRSLoginScreen.Debug(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  inherited;
end;

procedure TRSLoginScreen.Setup; override;
begin
  inherited;

  Self.Name := 'Login Screen';
end;

procedure TRSLoginScreen.Setup(Mode: ERSClientMode); overload;
begin
  Self.Mode := Mode;

  Self.Alignment.Left := [@RootInterface.X1];
  Self.Alignment.Right := [@RootInterface.X2];
  Self.Alignment.Top := [@RootInterface.Y1];
  Self.Alignment.Bottom := [@RootInterface.Y1, 502];
  Self.Alignment.Center := [764, 0];
end;

var
  LoginScreen: TRSLoginScreen;

procedure TRSClient.ClientModeChanged; override;
begin
  inherited;

  LoginScreen.Setup(Self.Mode);
end;

procedure TSRL.Setup; override;
begin
  inherited;

  LoginScreen.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  LoginScreen.Debug(Bitmap);
end;
