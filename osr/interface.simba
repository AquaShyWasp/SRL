{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

var
  RS_INTERFACE_BITMAP_PATH: String := IncludeTrailingPathDelimiter({$macro CURRENT_DIRECTORY}) + 'bitmaps/';

type
  TRSInterfaceButton = record
    // Bitmap
    Bitmap: TMufasaBitmap;

    // OCR
    Text: String;
    Font: String;
    Color: Int32;
  end;

  TRSInterfaceAlignment = record
    Method: function: Int32 of object;
    Offset: Int32;
  end;

  TRSInterface = record(TSRLBaseRecord)
    Buttons: array of TRSInterfaceButton;

    Alignment: record
      Left, Right, Top, Bottom: TRSInterfaceAlignment;

      Center: record
        MaxWidth: Single;
        MaxHeight: Single;

        (*
          To get a perfect alignment you need to mess with this.
          We need to recreate how RS aligns it's interfaces, however it isn't just
          an generic method. See BankScreen & DepositScreen for offsets used.

          Make sure to test the alignments by debugging the bounds, expanding
          client by one pixel, and debugging again.
        *)
        Offset: record
           X, Y: Single;
        end;
      end;
    end;
  end;

procedure TRSInterface.FreeButtons;
var
  I: Int32;
begin
  for I := 0 to High(Self.Buttons) do
    if (Self.Buttons[I].Bitmap <> nil) then
      Self.Buttons[I].Bitmap.Free();
end;

function TRSInterface.AddBitmapButton(Bitmap: String): TRSInterfaceButton;
var
  I: Int32;
begin
  for I := 0 to High(Self.Buttons) do
    if (Self.Buttons[I].Bitmap <> nil) and (Self.Buttons[I].Bitmap.GetName() = Bitmap) then
      Exit;

  Bitmap := RS_INTERFACE_BITMAP_PATH + Bitmap;
  if not FileExists(Bitmap) then
    Self.Fatal('Bitmap does not exist: ' + Bitmap);

  Result.Bitmap.Init(Client.GetMBitmaps());
  Result.Bitmap.LoadFromFile(Bitmap);
  Result.Bitmap.SetName(Bitmap);

  Self.Buttons := Self.Buttons + Result;
  if Length(Self.Buttons) = 1 then
    AddOnTerminate(@Self.FreeButtons);
end;

function TRSInterface.AddOCRButton(Text: String; Font: String; Color: Int32): TRSInterfaceButton;
begin
  Result.Text := Text;
  Result.Font := Font;
  Result.Color := Color;

  Self.Buttons := Self.Buttons + Result;
  if Length(Self.Buttons) = 1 then
    AddOnTerminate(@Self.FreeButtons);
end;

function TRSInterface.X1: Int32; constref;
var
  Left, Right: Int32;
  Width, Center: Single;
begin
  if (@Self.Alignment.Left.Method = nil) then
    Self.Fatal('No left anchor');

  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left) + Self.Alignment.Center.Offset.X;
    Center := Left + (Width / 2);

    Result := Max(
      Round(Center - (Width / 2)),
      Ceil(Center - (Self.Alignment.Center.MaxWidth / 2))
    );

  end else
    Result := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
end;
function TRSInterface.X2: Int32; constref;
var
  Left, Right: Int32;
  Width, Center: Single;
begin
  if (@Self.Alignment.Right.Method = nil) then
    Self.Fatal('No right anchor');

  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left) + Self.Alignment.Center.Offset.X;
    Center := Left + (Width / 2);

    Result := Min(
      Round(Center + (Width / 2)),
      Floor(Center + (Self.Alignment.Center.MaxWidth / 2))
    );
  end else
    Result := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;
end;

function TRSInterface.Y1: Int32; constref;
var
  Top, Bottom: Int32;
  Height, Center: Single;
begin
  if (@Self.Alignment.Top.Method = nil) then
    Self.Fatal('No top anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top) + Self.Alignment.Center.Offset.Y;
    Center := Top + (Height / 2);

    Result := Max(
      Round(Center - (Height / 2)),
      Ceil(Center - (Self.Alignment.Center.MaxHeight / 2))
    );
  end else
    Result := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
end;

function TRSInterface.Y2: Int32; constref;
var
  Top, Bottom: Int32;
  Height, Center: Single;
begin
  if (@Self.Alignment.Bottom.Method = nil) then
    Self.Fatal('No bottom anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top) + Self.Alignment.Center.Offset.Y;
    Center := Top + (Height / 2);

    Result := Min(
      Round(Center + (Height / 2)),
      Floor(Center + (Self.Alignment.Center.MaxHeight / 2))
    );
  end else
    Result := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;
end;

function TRSInterface.Bounds: TBox; constref;
begin
  Result := [Self.X1, Self.Y1, Self.X2, Self.Y2];
end;

function TRSInterface.Width: Int32; constref;
begin
  Result := Bounds.Width;
end;

function TRSInterface.Height: Int32; constref;
begin
  Result := Bounds.Height;
end;

function TRSInterface.Center: TPoint; constref;
begin
  Result := Self.Bounds().Middle;
end;

function TRSInterface.FindButton(Button: TRSInterfaceButton; out Bounds: TBox): Boolean; overload;
var
  X, Y: Int32;
begin
  if (Button.Bitmap <> nil) then
  begin
    Result := FindBitmapToleranceIn(Button.Bitmap.GetIndex(), X, Y, Self.Bounds, 5);
    if Result then
      Bounds := Bounds := [X, Y, X + Button.Bitmap.GetWidth() - 1, Y + Button.Bitmap.GetHeight() - 1];
  end else
  begin
    if (Button.Color = -1) then
      Result := FindText(Button.Text, Button.Font, Self.X1, Self.Y1, Self.X2, Self.Y2, Bounds) = 1
    else
      Result := FindTextColor(Button.Text, Button.Font, Button.Color, 0, Self.X1, Self.Y1, Self.X2, Self.Y2, Bounds) = 1;
  end;
end;

function TRSInterface.FindButton(Buttons: array of TRSInterfaceButton; out Bounds: TBox): Boolean; overload;
var
  I: Int32;
begin
  for I := 0 to High(Buttons) do
    if Self.FindButton(Buttons[I], Bounds) then
      Exit(True);
end;

function TRSInterface.FindButton(Button: TRSInterfaceButton): Boolean; overload;
var
  Bounds: TBox;
begin
  Result := FindButton(Button, Bounds);
end;

function TRSInterface.FindButton(Buttons: array of TRSInterfaceButton): Boolean; overload;
var
  I: Int32;
begin
  for I := 0 to High(Buttons) do
    if Self.FindButton(Buttons[I]) then
      Exit(True);
end;

procedure TRSInterface.Debug(Bitmap: TMufasaBitmap); overload;
var
  I: Int32;
  B: TBox;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);

  for I := 0 to High(Self.Buttons) do
    if Self.FindButton(Self.Buttons[I], B) then
      Bitmap.Rectangle(B, $00FF00, 0.50);
end;

function TRSInterface.ClickButton(Button: TRSInterfaceButton; Action: Int32): Boolean; overload;
var
  Bounds: TBox;
begin
  Result := Self.FindButton(Button, Bounds);
  if Result then
    Mouse.Click(SRL.rowp(Mouse.GetPosition(), Bounds), Action);
end;

function TRSInterface.ClickButton(Buttons: array of TRSInterfaceButton; Action: Int32): Boolean; overload;
var
  I: Int32;
begin
  for I := 0 to High(Buttons) do
    if Self.ClickButton(Buttons[I], Action) then
      Exit(True)
end;
