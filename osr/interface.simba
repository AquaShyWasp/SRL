{$DEFINE SRL_INTERFACE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSInterfaceAlignment = record
    Method: function: Int32 of object;
    Offset: Int32;
  end;

  TRSInterface = record(TSRLBaseRecord)
    Mode: ERSClientMode;
    
    ButtonColors: array of TCTS1Color;
    
    Alignment: record
      Left, Right, Top, Bottom: TRSInterfaceAlignment;

      Center: record
        MaxWidth: Int32;
        MaxHeight: Int32;
      end;
    end;
  end;

procedure TRSInterface.Setup; 
begin
  Self.Name := 'UNNAMED';
  Self.ButtonColors := [CTS1(5334129, 2), CTS1(2303648, 1), CTS1(657930, 20)];
end;
  
function TRSInterface.X1: Int32; constref;
var
  Left, Right, Width, Center: Single;
begin
  if (@Self.Alignment.Left.Method = nil) then
    Self.Fatal('No left anchor');

  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left);
    Center := Left + (Width / 2);

    Result := Max(
      Floor(Center - (Width / 2)),
      Floor(Center - ((Self.Alignment.Center.MaxWidth - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Left.Method() + Self.Alignment.Left.Offset)
end;

function TRSInterface.X2: Int32; constref;
var
  Left, Right, Width, Center: Single;
begin
  if (@Self.Alignment.Right.Method = nil) then
    Self.Fatal('No right anchor');
 
  if (Self.Alignment.Center.MaxWidth > 0) then
  begin
    Left := Self.Alignment.Left.Method() + Self.Alignment.Left.Offset;
    Right := Self.Alignment.Right.Method() + Self.Alignment.Right.Offset;

    Width := (Right - Left);
    Center := Left + (Width / 2);

    Result := Min(
      Floor(Center + (Width / 2)),
      Floor(Center + ((Self.Alignment.Center.MaxWidth - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Right.Method() + Self.Alignment.Right.Offset);
end;

function TRSInterface.Y1: Int32; constref;
var
  Top, Bottom, Height, Center: Single;
begin
  if (@Self.Alignment.Top.Method = nil) then
    Self.Fatal('No top anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top);
    Center := Top + (Height / 2);

    Result := Max(
      Floor(Center - (Height / 2)),
      Floor(Center - ((Self.Alignment.Center.MaxHeight - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Top.Method() + Self.Alignment.Top.Offset);
end;

function TRSInterface.Y2: Int32; constref;
var
  Top, Bottom, Height, Center: Single;
begin
  if (@Self.Alignment.Bottom.Method = nil) then
    Self.Fatal('No bottom anchor');

  if (Self.Alignment.Center.MaxHeight > 0) then
  begin
    Top := Self.Alignment.Top.Method() + Self.Alignment.Top.Offset;
    Bottom := Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset;

    Height := (Bottom - Top);
    Center := Top + (Height / 2);

    Result := Min(
      Floor(Center + (Height / 2)),
      Floor(Center + ((Self.Alignment.Center.MaxHeight - 1) / 2))
    );
  end else
    Result := Round(Self.Alignment.Bottom.Method() + Self.Alignment.Bottom.Offset);
end;

function TRSInterface.Bounds: TBox; constref;
begin
  Result := [Self.X1, Self.Y1, Self.X2, Self.Y2];
end;

function TRSInterface.Width: Int32; constref;
begin
  Result := Bounds.Width;
end;

function TRSInterface.Height: Int32; constref;
begin
  Result := Bounds.Height;
end;

function TRSInterface.Center: TPoint; constref;
begin
  Result := Self.Bounds().Middle;
end;

procedure TRSInterface.Debug(Bitmap: TMufasaBitmap); overload;
begin
  Bitmap.DrawBox(Self.Bounds(), $00FFFF);
end;

type
  TRSButton = record 
    Index: Int32; 
    Bounds: TBox; 
    Middle: TPoint;
  end;
  
  TRSButtonArray = array of TRSButton;
  TRSButtonDimensions = array of record Width, Height: Int32; end;
  
function TRSInterface.FindButtons(Dimensions: TRSButtonDimensions): TRSButtonArray;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  I, W, H: Int32;
  B: TBox;
  Color: TCTS1Color;
  Boxes: TBoxArray;
begin
  B := Self.Bounds();
  
  for Color in Self.ButtonColors do
    if SRL.FindColors(TPA, Color, B) > 0 then
      ATPA += TPA;
  
  ATPA := ATPA.Merge().Cluster(1);

  for TPA in ATPA do
  begin
    if Length(TPA) < 25 then
      Continue;
      
    B := TPA.Bounds();
    B.GetDimensions(W, H);

    for I := 0 to High(Dimensions) do
      if (W = Dimensions[I].Width) and (H = Dimensions[I].Height) and
         (TPA.Frameness() > 75) then
        Boxes += B;
      
    {$IFDEF SRL_DEBUG_FINDBUTTONS}        
    if (W > 10) and (H > 10) then
      Writeln(W, ', ', H);
    {$ENDIF}
  end;
  
  Boxes.SortByXY(10);
  
  SetLength(Result, Length(Boxes));
  for I := 0 to High(Boxes) do
  begin
    Result[I].Index := I;
    Result[I].Bounds := Boxes[I];
    Result[I].Middle := Boxes[I].Middle;
  end;
end;

function TRSButtonArray.ToBoxes: TBoxArray; constref;
var
  I: Int32;
begin
  SetLength(Result, Length(Self));
  for I := 0 to High(Result) do
    Result[I] := Self[I].Bounds;
end;

function TRSButton.Visible: Boolean; constref;
begin 
  Result := Self <> [];
end;

function TRSButton.Enabled: Boolean; constref;
begin
  Result := Self.Visible() and (SRL.CountColor(CTS1(2369440, 5), Self.Bounds) > 0);
end;

function TRSButton.Click: Boolean; constref;
begin
  Result := Self.Visible();
  if Result then
    Mouse.Click(Self.Bounds, MOUSE_LEFT);
end;

function TRSButton.Enable: Boolean; constref;
begin
  Result := Self.Enabled() or Self.Click();
end;

function TRSButton.Disable: Boolean; constref;
begin
  Result := not Self.Enabled() or Self.Click();
end;

function TRSButton.FindText(Text: String; Font: String): Boolean; constref; overload;
begin
  Result := System.FindText(Text, Font, Self.Bounds.X1, Self.Bounds.Y1, Self.Bounds.X2, Self.Bounds.Y2, 1);
end;

function TRSButton.FindText(Text: TStringArray; Font: String; out Found: String): Boolean; constref; overload;
var
  I: Int32;
begin
  for I := 0 to High(Text) do
    if Self.FindText(Text[I], Font) then
    begin
      Found := Text[I];
      
      Exit(True);
    end;
end;

procedure TMufasaBitmap.DrawButtons(Buttons: TRSButtonArray);
var
  I: Int32;
  S: String;
begin
  for I := 0 to High(Buttons) do
  begin
    S := ToStr(Buttons[I].Index);
    
    Self.Rectangle(Buttons[I].Bounds, $00FF00, 0.50);
    Self.DrawSystemText(S, 'Arial Bold', 15, Buttons[I].Middle.Offset(-Length(S)*5, -11), False, $0000FF);
  end;
end;

procedure Debug(Buttons: TRSButtonArray); overload;
var
  BMP: TMufasaBitmap;
begin
  BMP.FromClient();
  BMP.DrawButtons(Buttons);
  BMP.Debug();
  BMP.Free();
end;

