{$DEFINE SRL_BANKSCREEN_INCLUDED}
{$IFNDEF OSRS}
  {$include_once SRL/osr.simba}
{$ENDIF}

type
  ERSBankLocation = (BANK_LOCATION_CASTLE_WARS,
                     BANK_LOCATION_CLAN_WARS);

  TRSBankScreen = record(TRSInterface)
    BUTTON_REARRANGE_SWAP_OFF: TRSInterfaceButton;
    BUTTON_REARRANGE_SWAP_ON: TRSInterfaceButton;

    BUTTON_REARRANGE_INSERT_OFF: TRSInterfaceButton;
    BUTTON_REARRANGE_INSERT_ON: TRSInterfaceButton;

    BUTTON_WITHDRAW_ITEM_OFF: TRSInterfaceButton;
    BUTTON_WITHDRAW_ITEM_ON: TRSInterfaceButton;

    BUTTON_WITHDRAW_NOTE_OFF: TRSInterfaceButton;
    BUTTON_WITHDRAW_NOTE_ON: TRSInterfaceButton;

    BUTTON_QUANTITY_1_OFF: TRSInterfaceButton;
    BUTTON_QUANTITY_1_ON: TRSInterfaceButton;

    BUTTON_QUANTITY_5_OFF: TRSInterfaceButton;
    BUTTON_QUANTITY_5_ON: TRSInterfaceButton;

    BUTTON_QUANTITY_10_OFF: TRSInterfaceButton;
    BUTTON_QUANTITY_10_ON: TRSInterfaceButton;

    BUTTON_QUANTITY_CUSTOM_OFF: TRSInterfaceButton;
    BUTTON_QUANTITY_CUSTOM_ON: TRSInterfaceButton;

    BUTTON_QUANTITY_ALL_OFF: TRSInterfaceButton;
    BUTTON_QUANTITY_ALL_ON: TRSInterfaceButton;

    BUTTON_DEPOSIT_INVENTORY: TRSInterfaceButton;
    BUTTON_DEPOSIT_INVENTORY_HOVER: TRSInterfaceButton;

    BUTTON_DEPOSIT_EQUIPMENT: TRSInterfaceButton;
    BUTTON_DEPOSIT_EQUIPMENT_HOVER: TRSInterfaceButton;

    BUTTON_PLACEHOLDERS: TRSInterfaceButton;
    BUTTON_PLACEHOLDERS_HOVER: TRSInterfaceButton;

    BUTTON_SEARCH_OFF: TRSInterfaceButton;
    BUTTON_SEARCH_OFF_HOVER: TRSInterfaceButton;
    BUTTON_SEARCH_ON: TRSInterfaceButton;
    BUTTON_SEARCH_ON_HOVER: TRSInterfaceButton;

    BUTTON_CLOSE: TRSInterfaceButton;
    BUTTON_CLOSE_HOVER: TRSInterfaceButton;

    BUTTON_SCROLLED_TOP: TRSInterfaceButton;
  end;

function TRSBankScreen.GetSlotBoxes: TBoxArray; constref;
var
  Rows: Int32;
begin
  Rows := (Self.Height() - 120) div 35;

  Result := Grid(8, Rows, 31, 31, [17, 5], [Self.X1 + 57, Self.Y1 + 77]);
end;

function TRSBankScreen.GetTabBoxes: TBoxArray; constref;
begin
  Result := Grid(10, 1, 36, 30, [4, 0], [Self.X1 + 46, Self.Y1 + 42]);
end;

function TRSBankScreen.IsOpen: Boolean; overload;
var
  T: UInt64;
begin
  Result := Self.FindButton([Self.BUTTON_REARRANGE_SWAP_ON, Self.BUTTON_REARRANGE_SWAP_OFF]);
  if Result then
  begin
    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) and (SRL.CountColor(CTS0(65536), Self.GetSlotBoxes().Merge()) = 0) do
      Wait(25);
  end;
end;

function TRSBankScreen.IsOpen(WaitTime: Int32): Boolean; overload;
var
  T: UInt64;
begin
  T := GetTickCount() + WaitTime;

  while (T > GetTickCount()) do
  begin
     if Self.IsOpen() then
       Exit(True);

     Wait(0, 1000, wdLeft);
  end;
end;

procedure TRSBankScreen.Debug(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen then
    Exit;

  inherited;

  Bitmap.DrawBoxes(GetTabBoxes(), False, $00FFFF);
  Bitmap.DrawBoxes(GetSlotBoxes(), False, $00FFFF);
end;

procedure TRSBankScreen.Setup(ClientMode: ERSClientMode);
begin
  Self.Name := 'BankScreen';

  Self.BUTTON_REARRANGE_SWAP_OFF := Self.AddBitmapButton('bank_rearrange_swap_off.png');
  Self.BUTTON_REARRANGE_SWAP_ON := Self.AddBitmapButton('bank_rearrange_swap_on.png');

  Self.BUTTON_REARRANGE_INSERT_OFF := Self.AddBitmapButton('bank_rearrange_insert_off.png');
  Self.BUTTON_REARRANGE_INSERT_ON := Self.AddBitmapButton('bank_rearrange_insert_on.png');

  Self.BUTTON_WITHDRAW_ITEM_OFF := Self.AddBitmapButton('bank_withdraw_item_off.png');
  Self.BUTTON_WITHDRAW_ITEM_ON := Self.AddBitmapButton('bank_withdraw_item_on.png');

  Self.BUTTON_WITHDRAW_NOTE_OFF := Self.AddBitmapButton('bank_withdraw_note_off.png');
  Self.BUTTON_WITHDRAW_NOTE_ON := Self.AddBitmapButton('bank_withdraw_note_on.png');

  Self.BUTTON_QUANTITY_1_OFF := Self.AddBitmapButton('bank_quantity_1_off.png');
  Self.BUTTON_QUANTITY_1_ON := Self.AddBitmapButton('bank_quantity_1_on.png');

  Self.BUTTON_QUANTITY_5_OFF := Self.AddBitmapButton('bank_quantity_5_off.png');
  Self.BUTTON_QUANTITY_5_ON := Self.AddBitmapButton('bank_quantity_5_on.png');

  Self.BUTTON_QUANTITY_10_OFF := Self.AddBitmapButton('bank_quantity_10_off.png');
  Self.BUTTON_QUANTITY_10_ON := Self.AddBitmapButton('bank_quantity_10_on.png');

  Self.BUTTON_QUANTITY_CUSTOM_OFF := Self.AddBitmapButton('bank_quantity_custom_off.png');
  Self.BUTTON_QUANTITY_CUSTOM_ON := Self.AddBitmapButton('bank_quantity_custom_on.png');

  Self.BUTTON_QUANTITY_ALL_OFF := Self.AddBitmapButton('bank_quantity_all_off.png');
  Self.BUTTON_QUANTITY_ALL_ON := Self.AddBitmapButton('bank_quantity_all_on.png');

  Self.BUTTON_DEPOSIT_INVENTORY := Self.AddBitmapButton('bank_deposit_inventory.png');
  Self.BUTTON_DEPOSIT_INVENTORY_HOVER := Self.AddBitmapButton('bank_deposit_inventory_hover.png');

  Self.BUTTON_DEPOSIT_EQUIPMENT := Self.AddBitmapButton('bank_deposit_equipment.png');
  Self.BUTTON_DEPOSIT_EQUIPMENT_HOVER := Self.AddBitmapButton('bank_deposit_equipment_hover.png');

  Self.BUTTON_PLACEHOLDERS := Self.AddBitmapButton('bank_placeholders.png');
  Self.BUTTON_PLACEHOLDERS_HOVER := Self.AddBitmapButton('bank_placeholders_hover.png');

  Self.BUTTON_SEARCH_OFF := Self.AddBitmapButton('bank_search_off.png');
  Self.BUTTON_SEARCH_OFF_HOVER := Self.AddBitmapButton('bank_search_off_hover.png');
  Self.BUTTON_SEARCH_ON := Self.AddBitmapButton('bank_search_on.png');
  Self.BUTTON_SEARCH_ON_HOVER := Self.AddBitmapButton('bank_search_on_hover.png');

  Self.BUTTON_CLOSE := Self.AddBitmapButton('bank_close.png');
  Self.BUTTON_CLOSE_HOVER := Self.AddBitmapButton('bank_close_hover.png');

  Self.BUTTON_SCROLLED_TOP := Self.AddBitmapButton('bank_scrolled_top.png');

  if ClientMode in [RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM, RS_CLIENT_FIXED] then
  begin
    Self.Alignment.Left := [@InterfaceArea.X1];
    Self.Alignment.Right := [@InterfaceArea.X2];
    Self.Alignment.Top := [@InterfaceArea.Y1, 2];
    Self.Alignment.Bottom := [@InterfaceArea.Y2, -2];
    Self.Alignment.Center.MaxWidth := 488;
    Self.Alignment.Center.MaxHeight := 800;
  end;
end;

function TRSBankScreen.GetTitle: String;
var
  B: TBox;
  BMP: TMufasaBitmap;
  TPA: TPointArray;
begin
  B := Self.Bounds;
  B.X1 += 50;
  B.Y1 += 5;
  B.X2 -= 50;
  B.Y2 := B.Y1 + 25;

  BMP.FromClient(B);
  BMP.ThresholdAdaptive(0, 255, False, TM_Mean, 15);
  BMP.FindColors(TPA, $0000FF);
  with TPA.Bounds() do
    BMP.Crop(X1, Y1, X2, Y2);

  Result := OCR.Recognize(BMP.ToMatrix(), [255], RS_FONTSET_BOLD_12);

  BMP.Free();
end;

function TRSBankScreen.IsTitle(Text: String): Boolean; overload;
begin
  Result := Text in Self.GetTitle();
end;

function TRSBankScreen.IsTitle(Text: String; WaitTime: Int32): Boolean; overload;
var
  T: UInt64;
begin
  T := GetTickCount() + WaitTime;
  while (T > GetTickCount()) do
  begin
    if Self.IsTitle(Text) then
      Exit(True);

    Wait(0, 1000, wdLeft);
  end;
end;

function TRSBankScreen.Search(Item: String): Boolean;
begin
  if Self.IsTitle('Showing items: ' + LowerCase(Item)) then
    Exit(True);

  // Clear current search
  if Self.IsTitle('Showing items:') and (not Self.ClickButton(Self.BUTTON_SEARCH_OFF, MOUSE_LEFT)) then
    Exit(False);

  if Self.ClickButton(Self.BUTTON_SEARCH_ON, MOUSE_LEFT) and Chatbox.AnswerQuery('Show items', Item, Random(2000, 2500)) then
    Result := Self.IsTitle('Showing items: ' + LowerCase(Item), Random(2000, 2500));
end;

function TRSBankScreen.FindItems: TBoxArray; constref;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  Row: TPointArray;
  Rows: T2DPointArray;
  B: TBox;
begin
  if SRL.FindColors(TPA, CTS2(3358280, 1, 0.80, 0.41), Self.GetSlotBoxes().Merge()) > 0 then
  begin
    TPA := TPA.Invert();

    Rows := TPA.Cluster(100, 3);
    with GetATPABounds(Rows) do
      Rows.SortByIndex([X1, Y1]); // Sort top to bottom

    for Row in Rows do
    begin
      ATPA := Row.Cluster(3);
      with GetATPABounds(ATPA) do
        ATPA.SortByIndex([X1, Y1]); // Sort left to right

      for TPA in ATPA do
      begin
        B := TPA.Bounds();
        if (B.Width <= 36) and (B.Height <= 36) then
          Result := Result + TPA.Bounds();
      end;
    end;
  end;
end;

const
  BANK_WITHDRAW_ALL = -1;
  BANK_WITHDRAW_ALL_BUT_ONE = -2;


procedure TRSBankScreen.ScrollToTop;
begin
  if not Self.IsOpen() then
    Exit;

  while not Self.FindButton(Self.BUTTON_SCROLLED_TOP) do
    Mouse.Scroll(Self.GetSlotBoxes().Merge(), Random(1, 3), False);
end;

function TRSBankScreen.WithdrawItem(B: TBox; Amount: Int32; Noted: Boolean): Boolean; overload;
begin
  if Noted then
  begin
    if not Self.FindButton(Self.BUTTON_WITHDRAW_NOTE_ON) and
       not Self.ClickButton(Self.BUTTON_WITHDRAW_NOTE_OFF, MOUSE_LEFT) then
      Exit(False);
  end else
  begin
    if not Self.FindButton(Self.BUTTON_WITHDRAW_ITEM_ON) and
       not Self.ClickButton(Self.BUTTON_WITHDRAW_ITEM_OFF, MOUSE_LEFT) then
      Exit(False);
  end;

  Mouse.Move(B);

  case Amount of
    BANK_WITHDRAW_ALL:
      Result := ChooseOption.Select('Withdraw-All');
    BANK_WITHDRAW_ALL_BUT_ONE:
      Result := ChooseOption.Select('Withdraw-All-but-1');
    else
    begin
      if ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) then
        Exit(True);
      if ChooseOption.Select('Withdraw-X') and Chatbox.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500)) then
        Exit(True);
    end;
  end;
end;

function TRSBankScreen.WithdrawQuantity(B: TBox; Amount: String; Noted: Boolean): Boolean;
begin
  if Noted then
  begin
    if not Self.FindButton(Self.BUTTON_WITHDRAW_NOTE_ON) and
       not Self.ClickButton(Self.BUTTON_WITHDRAW_NOTE_OFF, MOUSE_LEFT) then
      Exit(False);
  end else
  begin
    if not Self.FindButton(Self.BUTTON_WITHDRAW_ITEM_ON) and
       not Self.ClickButton(Self.BUTTON_WITHDRAW_ITEM_OFF, MOUSE_LEFT) then
      Exit(False);
  end;

  case UpperCase(Amount) of
    '1':   Self.ClickButton(Self.BUTTON_QUANTITY_1_OFF, MOUSE_LEFT);
    '5':   Self.ClickButton(Self.BUTTON_QUANTITY_5_OFF, MOUSE_LEFT);
    '10':  Self.ClickButton(Self.BUTTON_QUANTITY_10_OFF, MOUSE_LEFT);
    'X':   Self.ClickButton(Self.BUTTON_QUANTITY_CUSTOM_OFF, MOUSE_LEFT);
    'ALL': Self.ClickButton(Self.BUTTON_QUANTITY_ALL_OFF, MOUSE_LEFT);
    else
      TerminateScript('TRSBankScreen.WithdrawQuantity: Invalid amount "' + Amount + '"');
  end;

  Mouse.Click(B, MOUSE_LEFT);
end;

function TRSBankScreen._Open(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  if MainScreen.IsUpText(['Use Bank', 'Bank chest', 'Bank Bank', 'Bank booth', 'Banker']) then
  begin
    // Right click
    if ('Banker' in MainScreen.GetUpText()) or (Random() < 0.10) then
    begin
      if (not ChooseOption.Select(['Use Bank', 'Bank Bank'])) then
        Exit(False);
    end else
    // Left click
    begin
      Mouse.Click(MOUSE_LEFT);

      if (not SRL.DidClick(RS_CLICK_RED)) then
        Exit(False);
    end;

    if Minimap.HasFlag(Random(400, 800)) then
      Minimap.WaitFlag();

    Result := Self.IsOpen(Random(2000, 4000));
  end;
end;

function TRSBankScreen._OpenChest(FrameColor, TextureColor: TCTS2Color): Boolean;
var
  FrameTPA, TextureTPA, TPA: TPointArray;
  ATPA: T2DPointArray;
  Magic: Int32;
  I: Int32;
  P: TPoint;
begin
  // This gives us a constant distance regardless of the zoom level
  Magic := Distance(Minimap.VecToMS([Minimap.Center.X, Minimap.Center.Y]),
                    Minimap.VecToMS([Minimap.Center.X + 1.2, Minimap.Center.Y]));

  if (Magic > 0) then
  begin
    SRL.FindColors(FrameTPA, FrameColor, MainScreen.Bounds);
    SRL.FindColors(TextureTPA, TextureColor, MainScreen.Bounds);

    // Get points where the frame and texture are close to eachother
    TPA := TextureTPA.PointsInRangeOf(FrameTPA, 0, Magic);

    // Remove noise by removing the TPA edge a few times
    for 1 to Magic div 4 do
      TPA := ClearTPAFromTPA(TPA, TPA.Edges());

    if Length(TPA) > 0 then
    begin
      // Split our matches into groups
      ATPA := TPA.Cluster(Magic div 4);
      ATPA.SortBySize();

      // Loop though the three largest groups
      for I := 0 to Min(High(ATPA), 3) do
      begin
        TPA := ATPA[I];

        P := TPA[Random(Length(TPA))];
        P.X += Random(-2, 2);
        P.Y += Random(-2, 2);

        if Self._Open(P) then
          Exit(True);
      end;
    end;
  end;
end;

function TRSBankScreen.Open(Location: ERSBankLocation): Boolean;
begin
  if Self.IsOpen() then
    Exit(True);

  case Location of
    BANK_LOCATION_CLAN_WARS,
    BANK_LOCATION_CASTLE_WARS:
      Result := Self._OpenChest(CTS2(5526875, 15, 0.19, 0.06), CTS2(2503237, 20, 0.10, 0.14));
  end;
end;


function TRSBankScreen.Close(): Boolean;
var
  t: UInt64;
begin
  if (not Self.IsOpen()) then
    Exit(True);

  Self.ClickButton([Self.BUTTON_CLOSE, Self.BUTTON_CLOSE_HOVER], MOUSE_LEFT);
  t := GetTickCount() + Random(4000, 5000);
  while (t > GetTickCount()) do
  begin
    if (not Self.IsOpen()) then
      Exit(True);
  end;
end;

function TRSBankScreen.EscapeClose(): Boolean;
var
  t: UInt64;
begin
  if (not Self.IsOpen()) then
    Exit(True);

  Keyboard.PressKey(VK_ESCAPE);
  t := GetTickCount() + Random(4000, 5000);
  while (t > GetTickCount()) do
  begin
    if (not Self.IsOpen()) then
      Exit(True);
  end;
end;


(*
BankScreen.DepositAll
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBankScreen.DepositAll(): Boolean;
Depositis your inventory by clicking the deposit inventory button
*)
function TRSBankScreen.DepositAll(): Boolean;
begin
  {if (Inventory.Count = 0) then
    Exit(True);}

  Result := Self.ClickButton(Self.BUTTON_DEPOSIT_INVENTORY, mouse_left);
end;

(*
BankScreen.DepositItem
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBankScreen.DepositItem(Slot:Int32; DepositAll:Boolean): Boolean;
Depeosit a single item, or all of it's kind from inventory.
*)
function TRSBankScreen.DepositItem(Slot:Int32; DepositAll:Boolean): Boolean;
var
  t: TCountDown;
begin
  if (not Self.IsOpen) then
    Exit(False);

  Result := not Inventory.IsSlotUsed(Slot);
  if (not Result) then
  begin
    Mouse.Move(Inventory.GetSlotBox(Slot)); Wait(40,90);

    if DepositAll then
    begin
      ChooseOption.Open();
      Result := ChooseOption.Select(['Deposit-All']);
    end else
    begin
      Mouse.Click(mouse_left);
      Result := True;
    end;

    // wait for and verify completion
    t.Init(2000);
    while (not t.IsFinished) and Inventory.IsSlotUsed(Slot) do  Wait(70,160);
    Result := not Inventory.IsSlotUsed(Slot);
  end;
end;


(*
BankScreen.Deposit
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBankScreen.Deposit(SlotArr: TIntegerArray): Boolean;
Depeosits all the given items / slots
*)
function TRSBankScreen.Deposit(SlotArr: TIntegerArray): Boolean;
var
  i,j:Int32;
  t:UInt64;
begin
  if (not self.IsOpen()) then
    Exit();

  for j:=0 to 1 do
  begin
    Result := True;
    for i:=0 to High(SlotArr) do
      if Inventory.IsSlotUsed(SlotArr[i]) then
      begin
        self.DepositItem(SlotArr[i], srl.GetItemAmount(Inventory.GetSlotBox(slotArr[i])) > 0);
        Wait(6,25);
      end;

    for i:=0 to High(SlotArr) do
      if InRange(SlotArr[i],0,27) then
      begin
        t := GetTickCount() + 200;
        repeat
          Result := not(inventory.IsSlotUsed(slotArr[i]));
        until (GetTickCount() > t) or Result;
      end;

    if Result then
      Break
    else
      Wait(180,265); //wait a bit before round 2
  end;
end;

function TRSBankScreen.WithdrawItem(Identifier: String; Amount: Int32; Noted: Boolean): Boolean; overload;
begin
  // Implemented in itemfinder.simba
end;

function TRSBankScreen.WithdrawQuantity(Identifier: String; Amount: String; Noted: Boolean): Boolean; overload;
begin
  // Implemented in itemfinder.simba
end;

function TRSBankScreen.Count(Identifer: String): Int32;
begin
  // Implemented in itemfinder.simba
end;

function TRSBankScreen.CountStack(Identifer: String): Int32;
begin
  // Implemented in itemfinder.simba
end;

var
  BankScreen: TRSBankScreen;

begin
  SRL.AddSetupMethod(@BankScreen.Setup);
  SRL.AddDebugMethod(@BankScreen.Debug);
end;

