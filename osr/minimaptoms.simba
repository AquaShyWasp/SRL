{$DEFINE SRL_MINIMAP_TO_MS_INCLUDED}
{$IFNDEF OSRS}
  {$include_once SRL/osr.simba}
{$ENDIF}

(*
Minimap to Mainscreen
=====================
The core for our minimap to mainscreen projection.
Supports rotation, and zoom, and resizable client.

MM2MS extends the Minimap interface as well as the mainscreen interface with 
functionality to convert coordinates to & from the minimap to the mainscreen.
*)

(*
MM2MS
-----
*)

(*
type TMinimapToMS
~~~~~~~~~~~~~~~~~
.. pascal:: 
  type
    TMinimapToMS = record
      BASE_W, BASE_H: Int32;        // the size of the area we project to (mainscreen size)
      MainScreen.Middle.X, MainScreen.Middle.Y: Int32;            // the center of the area we project to (mainscreen center)
      MMCX, MMCY: Int32;            // the center of the area we project from (minimap center)
      SCALE_MIN, SCALE_MAX: Double; // direct zoom (relates to BASE)
      ZOOM: Double;                 // current zoom
      YSHIFT: Double;               // zooming may cause mid-Y to shift
    end;
   
The comments explains it. This is the datastructure MM2MS uses.
*)
type
  TMinimapToMS = record
    BASE_W, BASE_H: Int32;
    SCALE_MIN, SCALE_MAX: Double;
    YSHIFT: Double;
    YLOOK: Double;
    ZOOM: Double;
  end;

procedure TMinimapToMS.SetZoomLevel(Level: Int32);
const
  ZoomLevelToRSZoom = [0.0000, 0.0025, 0.0065, 0.0100, 0.0130, 0.0165, 0.0205, 0.0235, 0.0280, 0.0310, 0.0350, 0.0390, 0.0430, 0.0430, 0.0465, 0.0515, 0.0555, 0.0605, 0.0645, 0.0690, 0.0740, 0.0785, 0.0835, 0.0885, 0.0935, 0.0990, 0.1045, 0.1095, 0.1150, 0.1205, 0.1260, 0.1325, 0.1385, 0.1455, 0.1505, 0.1585, 0.1635, 0.1635, 0.1705, 0.1775, 0.1845, 0.1925, 0.1995, 0.2055, 0.2145, 0.2215, 0.2305, 0.2365, 0.2465, 0.2545, 0.2635, 0.2725, 0.2825, 0.2905, 0.3005, 0.3105, 0.3195, 0.3285, 0.3405, 0.3555, 0.3615, 0.3705, 0.3825, 0.3825, 0.3945, 0.4065, 0.4185, 0.4305, 0.4425, 0.4575, 0.4695, 0.4815, 0.4965, 0.5115, 0.5265, 0.5385, 0.5535, 0.5685, 0.5835, 0.5985, 0.6165, 0.6315, 0.6495, 0.6645, 0.6825, 0.7035, 0.7215, 0.7215, 0.7395, 0.7575, 0.7815, 0.7995, 0.8175, 0.8355, 0.8595, 0.8835, 0.9015, 0.9255, 0.9495, 0.9735, 1.000];
begin
  Self.ZOOM := ZoomLevelToRSZoom[Level];
end;

function TMinimapToMS.GetDebugBitmap(Angle: Double = -1): TMufasaBitmap; overload;
var
  X, Y: Int32;
  Tile: Vector3;
  TPA: TPointArray;
begin
  if Angle = -1 then
    Angle := Minimap.GetCompassAngle(False);

  Result.FromClient();

  for X := Minimap.Center.X - 25 * 4 to Minimap.Center.X + 25 * 4 with 4 do
    for Y := Minimap.Center.Y - 25 * 4 to Minimap.Center.Y + 25 * 4 with 4 do
    begin
      Tile := Vec3(X, Y).RotateXY(Angle, Minimap.Center.X, Minimap.Center.Y);
      TPA := Minimap.VecToMsRect(Tile, Angle).ToTPA().Connect();

      Result.DrawTPA(TPA, $00FF00);
    end;
end;

procedure TMinimapToMS.Debug(BMP: TMufasaBitmap);
var
  Dot: TPoint;
begin
  for Dot in Minimap.GetDots(MINIMAP_DOT_NPC) do
    BMP.DrawRect(Minimap.VecToMSRect([Dot.X + 2.5, Dot.Y + 2.5]), $00FFFF);
  for Dot in Minimap.GetDots(MINIMAP_DOT_ITEM) do
    BMP.DrawRect(Minimap.VecToMSRect([Dot.X + 2.5, Dot.Y + 2.5]), $0000FF);
  for Dot in Minimap.GetDots(MINIMAP_DOT_PLAYER) do
    BMP.DrawRect(Minimap.VecToMSRect([Dot.X + 2.5, Dot.Y + 2.5]), $FFFFFF);
end;

procedure TMinimapToMS.DebugTiles(Angle: Double = -1);
var
  BMP: TMufasaBitmap;
begin
  BMP := Self.GetDebugBitmap(Angle);
  BMP.Debug();
  BMP.Free();
end;

function TMinimapToMS.Transform(coord: Vector3; matrix: TMatrix4; scaleMin, scaleMax: Double; MSCX, MSCY: Int32): Vector3; overload;
var
  p: Vector3;
  scale: Double;
begin
  scale := ScaleMin + ZOOM * (ScaleMax - ScaleMin);
  p := Vector3.TransformCoordinate(coord, matrix);
  Result.x := (+p.X * BASE_W * scale) + MSCX;
  Result.y := (-p.Y * BASE_H * scale) + MSCY + (zoom * YSHIFT);
end;

function TMinimapToMS.Project(Coords: Vector3Array; Rotation: Vector3): TPointArray; overload;
var
  vec: Vector3;
  viewMatrix, projMatrix, worldMatrix,transMatrix: TMatrix4;
  scaleMin, scaleMax: Double;
  MSCX, MSCY: Int32;
  i: Int32;
begin
  viewMatrix := TMatrix4.LookAtRH([0, YLOOK, 61], [0, 0, 1.3], Vector3_UnitY);
  projMatrix := TMatrix4.PerspectiveFovRH(Sqrt(2), 765 / 503, 0.01, 1.0);

  worldMatrix := TMatrix4.RotationYawPitchRoll(Rotation.Y, Rotation.X, Rotation.Z) * Matrix_Identity;
  transMatrix := worldMatrix * viewMatrix * projMatrix;

  scaleMin := SCALE_MIN * MainScreen.Height() / 503;
  scaleMax := SCALE_MAX * MainScreen.Height() / 503;

  MSCX := MainScreen.Center().X;
  MSCY := MainScreen.Center().Y;

  SetLength(Result, Length(Coords));
  for i := 0 to High(Coords) do
  begin
    vec := Transform(Coords[i], transMatrix, scaleMin, scaleMax, MSCX, MSCY);

    Result[i].X := Round(vec.x);
    Result[i].Y := Round(vec.y);
  end;
end;

function TMinimapToMS.Run(Arr: Vector3Array; Roll:Single=$FFFF): TPointArray;
var
  i, Level: Int32;
  P: TPoint;
begin
  if Self.ZOOM = -1 then
    Self.SetZoomLevel(Options.GetZoomLevel());

  P := Minimap.Center;
  for i := 0 to High(Arr) do
    Arr[i] := [Arr[i].X - P.X, (P.Y - Arr[i].Y), Arr[i].Z];

  Result := Project(Arr, Vec3(0, 0, PI*2 - Roll));
end;

procedure TMinimapToMS.Setup(ClientMode: ERSClientMode);
begin
  Self.ZOOM := -1;

  Self.BASE_W := 513;
  Self.BASE_H := 335;

  Self.YSHIFT := 24;

  case ClientMode of
    RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM:
      begin
        Self.SCALE_MIN := 0.635;
        Self.SCALE_MAX := 4.9;

        Self.YLOOK := -21;
      end;

    RS_CLIENT_FIXED:
      begin
        Self.SCALE_MIN := 0.80;
        Self.SCALE_MAX := 6.32;

        Self.YLOOK := -25.5;
      end;
  end;
end;

(*
var MM2MS
~~~~~~~~~
.. pascal::
  var MM2MS: TMinimapToMS;

The global variable which you would refer to.
*)
var
  MM2MS: TMinimapToMS;

(*
Minimap
------------------------------------------------------
Extend the minimap-functionality with MM2MS functions
*)

(*
Minimap.ArrToMs
~~~~~~~~~~~~~~~
.. pascal:: 
  function TRSMinimap.ArrToMs(Arr: Vector3Array; Roll:Single=$FFFF): TPointArray; overload;
  function TRSMinimap.ArrToMs(Arr: TPointArray; Roll:Single=$FFFF): TPointArray; overload;

Takes array of points on the minimap, returns mainscreen projected array of points.
The first method takes a vector3 array as input, so we can pass height as well, and more detailed coordinates to scale.
*)
function TRSMinimap.ArrToMs(Arr: Vector3Array; Roll:Single=$FFFF): TPointArray; overload;
var
  i: Int32;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  for i:=0 to High(Arr) do
    Arr[i] := Arr[i].RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);
  
  Result := MM2MS.Run(Arr, Roll);
end;

function TRSMinimap.ArrToMs(Arr: TPointArray; Roll:Single=$FFFF): TPointArray; overload;
var
  VecArr: Vector3Array;
  i: Int32;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  
  SetLength(VecArr, Length(Arr));
  for i:=0 to High(Arr) do
  begin
    VecArr[i].x := Arr[i].x;
    VecArr[i].y := Arr[i].y;
    VecArr[i] := VecArr[i].RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);
  end;
  Result := MM2MS.Run(VecArr, Roll);
end;

(*
Minimap.VecToMs
~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.VecToMs(Vec: Vector3; Roll:Single=$FFFF): TPoint;

Takes a single coordinate as a Vector3 on the minimap, and converts it to a point on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.VecToMs(Vec: Vector3; Roll:Single=$FFFF): TPoint;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);
  
  Result := MM2MS.Run([Vec], Roll)[0];
end;

(*
Minimap.PointToMs
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.PointToMs(PT: TPoint; Roll:Single=$FFFF): TPoint;

Takes a single coordinate as a TPoint on the minimap, and converts it to a point on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.PointToMs(PT: TPoint; Roll:Single=$FFFF): TPoint;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  pt := pt.Rotate(PI*2 - Roll, Point(Minimap.Center.X, Minimap.Center.Y));
  
  Result := MM2MS.Run([Vec3(PT.x, PT.y)], Roll)[0];
end;


(*
Minimap.VecToMsRect
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.VecToMsRect(Vec: Vector3; Roll:Single=$FFFF): TRectangle;

Takes a single coordinate as a Vector3 on the minimap, and converts it to a rectangle / tile on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.VecToMsRect(Vec: Vector3; Roll:Single=$FFFF): TRectangle;
var
  arr: TPointArray;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.x-2, Vec.y-2, Vec.z), Vec3(Vec.x+2, Vec.y-2, Vec.z), Vec3(Vec.x+2, Vec.y+2, Vec.z), Vec3(Vec.x-2, Vec.y+2, Vec.z)], Roll);
  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;

(*
Minimap.PointToMsRect
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.PointToMsRect(PT: TPoint; Roll:Single=$FFFF): TRectangle;

Takes a single coordinate as a TPoint on the minimap, and converts it to a rectangle / tile on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.PointToMsRect(PT: TPoint; Roll:Single=$FFFF): TRectangle;
var
  arr: TPointArray;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  pt := pt.Rotate(PI*2 - Roll, Point(Minimap.Center.X, Minimap.Center.Y));
  
  Arr := MM2MS.Run([Vec3(PT.x-2, PT.y-2), Vec3(PT.x+2, PT.y-2), Vec3(PT.x+2, PT.y+2), Vec3(PT.x-2, PT.y+2)], Roll);
  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;

(*
Minimap.VecToMsBox
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.VecToMsBox(Vec: Vector3; Roll:Single=$FFFF): TBox;

Takes a single coordinate as a Vector3 on the minimap, and converts it to a rough box on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.VecToMsBox(Vec: Vector3; Roll:Single=$FFFF): TBox;
var
  arr: TPointArray;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.x-2, Vec.y-2, Vec.z), Vec3(Vec.x+2, Vec.y-2, Vec.z), Vec3(Vec.x+2, Vec.y+2, Vec.z), Vec3(Vec.x-2, Vec.y+2, Vec.z)], Roll);
  Result := GetTPABounds(arr);
end;

(*
Minimap.VecToMsBox
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.PointToMsBox(PT: TPoint; Roll:Single=$FFFF): TBox;

Takes a single coordinate as a TPoint on the minimap, and converts it to a rough box on the mainscreen.

*ROLL is the compass angle, by leaving it default it will gather the compass angle itself.*
*)
function TRSMinimap.PointToMsBox(PT: TPoint; Roll:Single=$FFFF): TBox;
var
  arr: TPointArray;
begin
  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  PT := PT.Rotate(PI*2 - Roll, Point(Minimap.Center.X, Minimap.Center.Y));

  Arr := MM2MS.Run([Vec3(PT.x-2, PT.y-2), Vec3(PT.x+2, PT.y-2), Vec3(PT.x+2, PT.y+2), Vec3(PT.x-2, PT.y+2)], Roll);
  Result := GetTPABounds(arr);
end;

(*
Minimap.StaticToMsRect
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.StaticToMsRect(StaticMMPoint: TPoint; Height:Int32=0): TRectangle;

Takes static minimap coordinate, rotates it to compass angle, and returns a rectangle on the mainscreen
The static point is therefor gathered at north, and it will rotate it as expected.
*)
function TRSMinimap.StaticToMsRect(StaticMMPoint: TPoint; Height:Int32=0): TRectangle;
var
  angle: Double;
begin
  angle := Minimap.GetCompassAngle(False);
  with StaticMMPoint.Rotate(angle, Point(Minimap.Center.X, Minimap.Center.Y)) do
    Result := Minimap.VecToMSRect(Vec3(X,Y, Height), angle);
end;

(*
Minimap.StaticToMs
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.StaticToMs(StaticMMPoint: TPoint; Height:Int32=0): TPoint;

This is the same as the above, only that it returns a single point on the mainscreen.
*)
function TRSMinimap.StaticToMs(StaticMMPoint: TPoint; Height:Int32=0): TPoint;
var
  angle: Double;
begin
  angle := Minimap.GetCompassAngle(False);
  with StaticMMPoint.Rotate(angle, Point(Minimap.Center.X, Minimap.Center.Y)) do
    Result := Minimap.VecToMS(Vec3(X,Y, Height), angle);
end;



(*
Mainscreen
-------------------------------------------------------
Extend the mainscreen-functionality with MS2MM function
*)

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32=0; Accuracy:Double=0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply 
done by calling `.ToPoint` on the result.

**Example**

.. pascal::
  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32=0; Accuracy:Double=0.2): Vector3; override;
var
  a: Double := Minimap.GetCompassAngle(False);
  mid: TPoint := Minimap.Center();

  function FindNearest(Area, Step: Double; FromMM: Vector3; IsFinal: Boolean): Vector3;
  var
    i: Int32;
    TPA: TPointArray;
    arr,raw: Vector3Array;
    best: TPoint;
    x,y: Double;
  begin
    best := Point(-9999, -9999);
    x := FromMM.X-Area;
    while x <= FromMM.X+Area do
    begin
      y := FromMM.Y-Area;
      while y <= FromMM.Y+Area do
      begin
        raw += Vector3([x,y,height]);
        arr += raw[High(raw)].RotateXY(-a, mid.X, mid.Y);
        y += Step;
      end;
      x += Step;
    end;

    TPA := Minimap.ArrToMs(Copy(arr), a);
    if not IsFinal then Swap(arr, raw);
    for i:=0 to High(TPA) do
      if Distance(TPA[i], MS) < Distance(best, MS) then
      begin
        best := TPA[i];
        Result := arr[i];
      end;
    Result.z := Height;
  end;

var
  area: Double;
begin
  area := 48;
  Result := FindNearest(area, area, Vec3(mid.X, mid.Y), False);
  while area > accuracy do
  begin
    Result := FindNearest(area, area, Result, False);
    area /= 2;
  end;
  Result := FindNearest(area, accuracy, Result, True);
end;

(*
MainScreen.TranslateDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32;

Roughly translates a distance acquired at a specific zoom level to the current zoom level.

**Example:**

.. pascal::

  // 10 pixels at 50 zoom is currently X pixels at our current zoom level.
  WriteLn(MainScreen.TranslateDistance(10, 50));
*)
function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32; override;
var
  MinimapToMS: TMinimapToMS;
  MinimapCenter: TPoint;

  function Run(X: Double): Double;
  var
    TPA: TPointArray;
  begin
    TPA := MinimapToMS.Run([Vec3(MinimapCenter.X, MinimapCenter.Y),
                            Vec3(MinimapCenter.X + X, MinimapCenter.Y)], 0);

    Result := TPA[0].DistanceTo(TPA[1]);
  end;

var
  Lo, Hi: Double;
  X: Double;
  I: Int32;
begin
  if (Dist = 0) then
    Exit;

  if InRange(Zoom, Low(Self.TranslateCache), High(Self.TranslateCache)) and
     InRange(Dist, Low(Self.TranslateCache[Zoom]), High(Self.TranslateCache[Zoom])) then
  begin
    Result := Self.TranslateCache[Zoom][Dist];
    if Result > -1 then
      Exit;
  end;

  MinimapToMS.Setup(SRL.ClientMode); // Init MM2MS at the zoom level `dist` was calculated at
  MinimapToMS.SetZoomLevel(Zoom);

  MinimapCenter := Minimap.Center;

  Lo := Dist;
  while Run(Lo) >= dist do
    Lo -= Lo / 20;

  Hi := Lo;
  while Run(Hi) <= dist do
    Hi += Hi / 20;

  X := Lo + ((Hi - Lo) / 2);

  Result := Distance(
    Minimap.VecToMs(Vec3(MinimapCenter.X, MinimapCenter.Y), 0),
    Minimap.VecToMs(Vec3(MinimapCenter.X + X, MinimapCenter.Y), 0)
  );

  Self.TranslateCache[Zoom][Dist] := Result;
end;

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox; override;
var
  A: Double := Minimap.GetCompassAngle(False);
  Center: TPoint := Minimap.Center;
  TPA: TPointArray;
begin
  TPA := [Minimap.VecToMS(Vec3(Center.X - 2, Center.Y, 10), A),
          Minimap.VecToMS(Vec3(Center.X + 2, Center.Y, -3), A)];

  Result := TPA.Bounds();
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean; override;
var
  Angle: Double;
begin
  Angle := Self.PointToMM(P).ToPoint.AngleBetween(Minimap.Center);
  Angle += Random(-Randomness, Randomness);

  Minimap.SetCompassAngle(Angle);
end;

begin
  SRL.AddSetupMethod(@MM2MS.Setup);
  // SRL.AddDebugMethod(@MM2MS.Debug);
end;
