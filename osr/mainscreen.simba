{$DEFINE SRL_MAINSCREEN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

type
  TRSObjectFinder = record
    Colors: array of TCTS2Color;
    ColorClusters: array of record Primary, Secondary: TCTS2Color; Distance: Int32;end;
    ClusterDistance: Int32;
    Erode: Int32;
    Grow: Int32;
    MinLongSide, MaxLongSide: Int32;
    MinShortSide, MaxShortSide: Int32;
  end;

  TRSMainScreen = record(TRSInterface)
    UpTextArea: TBox;
    UpTextFilter: TCompareRules;
  end;

var
  MainScreen: TRSMainScreen;

procedure TRSMainScreen.Setup(ClientMode: ERSClientMode);
var
  I, J: Int32;
begin
  Self.Name := 'MainScreen';

  case ClientMode of
    RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM:
      begin
        Self.Alignment.Left := [@RootInterface.X1];
        Self.Alignment.Right := [@RootInterface.X2];
        Self.Alignment.Top := [@RootInterface.Y1];
        Self.Alignment.Bottom := [@RootInterface.Y2];

        Self.UpTextArea := [3, 3, 500, 21];
      end;

    RS_CLIENT_FIXED:
      begin
        Self.Alignment.Left := [@RootInterface.X1, 4];
        Self.Alignment.Right := [@RootInterface.X1, 515];
        Self.Alignment.Top := [@RootInterface.Y1, 4];
        Self.Alignment.Bottom := [@RootInterface.Y1, 337];

        Self.UpTextArea := [7, 7, 500, 25];
      end;
  end;

  Self.UpTextFilter := [-1, 85, True, 50];
end;

function TRSMainScreen.GetUpText(): String;
begin
  Result := OCR.Recognize(Self.UpTextArea, Self.UpTextFilter, RS_FONTSET_BOLD_12_SHADOW);

  {$IFDEF UPTEXT_DEBUG}
  Self.Debug('UpText: ' + Result);
  {$ENDIF}
end;

function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean; overload;

  function IsUpText: Boolean;
  var
    I: Int32;
    UpText: String;
  begin
    UpText := Self.GetUpText();

    for I := 0 to High(Text) do
      if (Text[I] in UpText) or (Text[I] = UpText) then
        Exit(True);
  end;

var
  T: UInt64;
begin
  if (Timeout = -1) then
    T := GetTickCount() + Round(SRL.SkewedRand(100, 85, 250))
  else
    T := GetTickCount() + Timeout;

  repeat
    if IsUpText() then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText() then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= T);
end;

function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean; overload;
begin
  Result := Self.IsUpText([Text], Timeout);
end;

(*
MainScreen.ConvertDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;

Converts a distance acquired from the **fixed client* and **default zoom(50)** to the
current mainscreen.

**Example:**

.. pascal::

  // 20 pixels on the fixed client and default zoom(50) is currently x pixels on the mainscreen.
  WriteLn(MainScreen.TranslateDistance(20));
*)
function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;
begin
  // Implemented in minimaptoms.simba
end;


(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply
done by calling `.ToPoint` on the result.

**Example**

.. pascal::
  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;
begin
  // Implemented in minimaptoms.simba
end;

function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray; overload;
var
  TPA, Primary, Secondary: TPointArray;
  ATPA: T2DPointArray;
  I: Int32;
  L, S: Int32;
begin
  Area.LimitTo(Self.Bounds());

  // Translate distances
  Finder.ClusterDistance := Self.ConvertDistance(Finder.ClusterDistance);
  Finder.Erode := Self.ConvertDistance(Finder.Erode);
  Finder.Grow := Self.ConvertDistance(Finder.Grow);

  Finder.ColorClusters := Copy(Finder.ColorClusters); // Make a copy!
  for I := 0 to High(Finder.ColorClusters) do
    Finder.ColorClusters[I].Distance := Self.ConvertDistance(Finder.ColorClusters[I].Distance);

  Finder.MinLongSide  := Self.ConvertDistance(Finder.MinLongSide);
  Finder.MaxLongSide  := Self.ConvertDistance(Finder.MaxLongSide);
  Finder.MinShortSide := Self.ConvertDistance(Finder.MinShortSide);
  Finder.MaxShortSide := Self.ConvertDistance(Finder.MaxShortSide);

  if (Finder.MaxLongSide = 0) then
    Finder.MaxLongSide := $FFFFFF;
  if (Finder.MaxShortSide = 0) then
    Finder.MaxShortSide := $FFFFFF;

  // Find colors
  for I := 0 to High(Finder.Colors) do
    if SRL.FindColors(TPA, Finder.Colors[I], Area) > 0 then
      ATPA += TPA;

  // Find color clusters
  for I := 0 to High(Finder.ColorClusters) do
    if (SRL.FindColors(Primary, Finder.ColorClusters[I].Primary, Area) > 0) and
       (SRL.FindColors(Secondary, Finder.ColorClusters[I].Secondary, Area) > 0) then
    begin
      TPA := Primary.PointsInRangeOf(Secondary, 0, Finder.ColorClusters[I].Distance);

      if TPA <> [] then
        ATPA += TPA;
    end;

  TPA := ATPA.Merge();

  // Process TPA
  if (Length(TPA) > 0) then
  begin
    if (Finder.Grow > 0) then
      TPA := TPA.Grow(Finder.Grow);
    if (Finder.Erode > 0) then
      TPA := TPA.Erode(Finder.Erode);

    if Length(TPA) > 0 then
    begin
      ATPA := TPA.Cluster(Finder.ClusterDistance);

      if (Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0) or (Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0) then
      begin
        for I := 0 to High(ATPA) do
        begin
          ATPA[I].Edges().MinAreaRectEx(L, S);

          if ((Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0)) and (not InRange(S, Finder.MinShortSide, Finder.MaxShortSide)) then
            Continue;
          if ((Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0)) and (not InRange(L, Finder.MinLongSide, Finder.MaxLongSide)) then
            Continue;

          Result += ATPA[I];
        end;
      end else
        Result := ATPA;
    end;

    Result.SortBySize();
  end;
end;

function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray; overload;
begin
  Result := MainScreen.FindObject(Finder, Self.Bounds());
end;

begin
  SRL.AddSetupMethod(@MainScreen.Setup);
  SRL.AddDebugMethod(@MainScreen.Debug);
end;
