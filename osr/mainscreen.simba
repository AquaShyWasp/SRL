(*
MainScreen
==========
*)

{$DEFINE SRL_MAINSCREEN_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL/osr.simba}
{$ENDIF}

{.$DEFINE SRL_DEBUG_MOUSE} // Enable me print uptext recognition


(*
type TRSObjectFinder
~~~~~~~~~~~~~~~~~~~~

TRSObjectFinder is the record used in **MainScreen.FindObject**.

* **TRSObjectFinder.Zoom**

  When designing a object finder you **must** be at **default zoom(50)** in the **fixed** client mode.
  This allows SRL to convert the finder to work at any zoom and client mode once made.

  .. figure:: ../../images/zoom.png

    A finder working at different zoom levels producing similar results.

* **TRSObjectFinder.Colors**

  An color array which will searched for. Use ACA to acquire color(s).

  .. pascal::

    Finder.Colors += CTS2(2503237, 20, 0.10, 0.14); // brown
    Finder.Colors += CTS2(5526875, 15, 0.19, 0.06); // grey

  .. figure:: ../../images/color_array.png

    The two colors above found and merged together.

* **TRSObjectFinder.ColorClusters**

  An array of "color clusters" which will be merged together. Use ACA to acquire color(s).

  A "color cluster" consists of a `primary` and `secondary` color and a `distance` value.
  When searched for only `primary` colors within `distance` of `secondary` colors are returned.

  .. pascal::

    Finder.ColorClusters += [
      CTS2(2503237, 20, 0.10, 0.14), // brown
      CTS2(5526875, 15, 0.19, 0.06), // grey
      2                              // distance
    ];

  .. figure:: ../../images/color_cluster.png

    The above color cluster found where "brown" is within 2 pixels of "grey".

* **TRSObjectFinder.Erode**

  The amount to erode before clustering. This is useful for removing small amounts of noise.

  .. pascal::

     Finder.Erode := 2;

  .. figure:: ../../images/erode.png

    Erode before and after.

* **TRSObjectFinder.Grow**

  The amount to grow **before** eroding. This is useful for filling gaps.

  .. pascal::

     Finder.Grow := 2;

  .. figure:: ../../images/grow.png

    Grow before and after.

  Grow can also be paired with erode which is quite powerful.

  .. pascal::

   Finder.Grow := 3;
   Finder.Erode := 4;

  .. figure:: ../../images/grow_erode.png

    Grow paired with Erode.

* **TRSObjectFinder.ClusterDistance**

  The distance to pass to *ClusterTPA*, this is how multiple objects are grouped up. `Distance=5` would mean that points that are closer than or equal to 5 pixels away are considered close enough to merge into a singular group.

  .. pascal::

     Finder.ClusterDistance := 5;

  .. figure:: ../../images/cluster_5.png

    Cluster distance **5** produces four individual chairs

  .. pascal::

     Finder.ClusterDistance := 20;

  .. figure:: ../../images/cluster_20.png

    Cluster distance **20** produces two sets of chairs

*  **TRSObjectFinder.MinLongSide, TRSObjectFinder.MaxLongSide, TRSObjectFinder.MinShortSide, TRSObjectFinder.MaxShortSide**

  Any match that exceeds these values will be removed.
  The bounding rectangle is used which has a **long** and a **short** side measured in pixels.

  .. pascal::

    // Removes matches where the short side isn't within 10 and 20 pixels
    Finder.MinShortSide := 10;
    Finder.MaxShortSide := 20;
    // Removes matches where the long side isn't within 20 and 40 pixels
    Finder.MinLongSide := 20;
    Finder.MaxLongSide := 40;

  .. figure:: ../../images/bounding_rect.png

    Example bounding rectangle with a long and short side.
*)
type
  TRSObjectFinder = record
    Colors: array of TCTS2Color;
    ColorClusters: array of record Primary, Secondary: TCTS2Color; Distance: Int32;end;
    ClusterDistance: Int32;
    Erode: Int32;
    Grow: Int32;
    MinLongSide, MaxLongSide: Int32;
    MinShortSide, MaxShortSide: Int32;
  end;

  TRSMainScreen = record(TRSInterface)
    UpTextArea: TBox;
    UpTextFilter: TCompareRules;
  end;

(*
MainScreen.Setup
~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMainScreen.Setup(ClientMode: ERSClientMode);

Setups the mainscreen.

.. note:: This is automatically called on the **MainScreen** variable.
*)
procedure TRSMainScreen.Setup;
begin
  Self.Name := 'MainScreen';
  Self.Mode := RSClient.Mode;

  case Self.Mode of
    RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM:
      begin
        Self.Alignment.Left := [@RootInterface.X1];
        Self.Alignment.Right := [@RootInterface.X2];
        Self.Alignment.Top := [@RootInterface.Y1];
        Self.Alignment.Bottom := [@RootInterface.Y2];

        Self.UpTextArea := [3, 3, 500, 21];
      end;

    RS_CLIENT_FIXED:
      begin
        Self.Alignment.Left := [@RootInterface.X1, 4];
        Self.Alignment.Right := [@RootInterface.X1, 515];
        Self.Alignment.Top := [@RootInterface.Y1, 4];
        Self.Alignment.Bottom := [@RootInterface.Y1, 337];

        Self.UpTextArea := [7, 7, 500, 25];
      end;
  end;

  Self.UpTextFilter.Color := -1;
  Self.UpTextFilter.Tolerance := 85;
  Self.UpTextFilter.UseShadow := True;
  Self.UpTextFilter.ShadowMaxValue := 70;
  Self.UpTextFilter.MinCharacterMatch := 18; // Filter out tiny characters (likely junk)
end;

(*
MainScreen.GetUpText
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetUpText: String;

Returns the current uptext.
Uptext is the top left which appears when moving the mouse over a object.

**Example**

  WriteLn(MainScreen.GetUpText());
*)
function TRSMainScreen.GetUpText: String;
begin
  Result := OCR.Recognize(Self.UpTextArea, Self.UpTextFilter, RS_FONTSET_BOLD_12_SHADOW, True);

  {$IFDEF SRL_DEBUG_UPTEXT}
  Self.Debug('UpText: ' + Result);
  {$ENDIF}
end;

(*
MainScreen.IsUpText
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean;

Returns true if the uptext is found **anywhere** in either of the **Text** strings.

**Example**

  WriteLn(MainScreen.MainScreen.IsUpText(['Chicken', 'Wolf']));
*)
function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean; overload;

  function IsUpText: Boolean;
  var
    I: Int32;
    UpText: String;
  begin
    UpText := Self.GetUpText();

    for I := 0 to High(Text) do
      if (Text[I] in UpText) or (Text[I] = UpText) then
        Exit(True);
  end;

var
  T: UInt64;
begin
  if (Timeout = -1) then
    T := GetTickCount() + Round(SRL.SkewedRand(100, 85, 250))
  else
    T := GetTickCount() + Timeout;

  repeat
    if IsUpText() then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText() then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= T);
end;

(*
MainScreen.IsUpText
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean;

Overloaded function that accepts a string rather than a TStringArray.

**Example**

  WriteLn(MainScreen.IsUpText('Chicken'));
*)
function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean; overload;
begin
  Result := Self.IsUpText([Text], Timeout);
end;

(*
MainScreen.SetHighestPitch
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMainScreen.SetHighestPitch;

Moves the camera to the highest pitch.
There is no way to detect the camera pitch reliably using color, this is why SRL only provides this method.

**Example**

  MainScreen.SetHighestPitch();
*)
procedure TRSMainScreen.SetHighestPitch;
begin
  Keyboard.KeyDown(VK_UP);

  try
    for 1 to 10 do // 2500ms timeout
      if (SRL.GetPixelShift(Self.Bounds(), 250) / Self.Bounds.Area() * 100) < 10 then // less than 10% of the screen changed in 250ms
        Break;
  finally
    Keyboard.KeyUp(VK_UP);
  end;
end;

(*
MainScreen.ConvertDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;

Converts a distance acquired from the **fixed client** and **default zoom(50)** to the
current mainscreen.

**Example**

  // 20 pixels on the fixed client and default zoom(50) is currently x pixels on the mainscreen.
  WriteLn(MainScreen.TranslateDistance(20));
*)
function TRSMainScreen.ConvertDistance(Dist: Int32; Accuracy: Single = 1.05): Int32;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply
done by calling `.ToPoint` on the result.

**Example**

  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.FindObject
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray;

Returns all matches of an TRSObjectFinder in the desired area.

See the top of this page page for documentation about the TRSObjectFinder record.

**Example**

  var MyFinder: TRSObjectFinder;

  // Some chairs in varrock west bank
  MyFinder.Colors += CTS2(1328725, 6, 0.06, 0.69);
  MyFinder.ClusterDistance := 5;
  MyFinder.Erode := 2;
  MyFinder.MinLongSide := 10;
  MyFinder.MaxLongSide := 15;

  Debug(MainScreen.FindObject(MyFinder, MainScreen.Bounds()));
*)
function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray; overload;
var
  TPA, Primary, Secondary: TPointArray;
  ATPA: T2DPointArray;
  I: Int32;
  L, S: Int32;
begin
  if Finder = [] then
    Self.Fatal('Empty TRSObjectFinder passed');

  Area.LimitTo(Self.Bounds());

  // Translate distances
  Finder.ClusterDistance := Self.ConvertDistance(Finder.ClusterDistance);
  Finder.Erode := Self.ConvertDistance(Finder.Erode);
  Finder.Grow := Self.ConvertDistance(Finder.Grow);

  Finder.ColorClusters := Copy(Finder.ColorClusters); // Make a copy!
  for I := 0 to High(Finder.ColorClusters) do
    Finder.ColorClusters[I].Distance := Self.ConvertDistance(Finder.ColorClusters[I].Distance);

  Finder.MinLongSide  := Self.ConvertDistance(Finder.MinLongSide);
  Finder.MaxLongSide  := Self.ConvertDistance(Finder.MaxLongSide);
  Finder.MinShortSide := Self.ConvertDistance(Finder.MinShortSide);
  Finder.MaxShortSide := Self.ConvertDistance(Finder.MaxShortSide);

  if (Finder.MaxLongSide = 0) then
    Finder.MaxLongSide := $FFFFFF;
  if (Finder.MaxShortSide = 0) then
    Finder.MaxShortSide := $FFFFFF;

  // Find colors
  for I := 0 to High(Finder.Colors) do
    if SRL.FindColors(TPA, Finder.Colors[I], Area) > 0 then
      ATPA += TPA;

  // Find color clusters
  for I := 0 to High(Finder.ColorClusters) do
    if (SRL.FindColors(Primary, Finder.ColorClusters[I].Primary, Area) > 0) and
       (SRL.FindColors(Secondary, Finder.ColorClusters[I].Secondary, Area) > 0) then
    begin
      TPA := Primary.PointsInRangeOf(Secondary, 0, Finder.ColorClusters[I].Distance);

      if TPA <> [] then
        ATPA += TPA;
    end;

  TPA := ATPA.Merge();

  // Process TPA
  if (Length(TPA) > 0) then
  begin
    if (Finder.Grow > 0) then
      TPA := TPA.Grow(Finder.Grow);
    if (Finder.Erode > 0) then
      TPA := TPA.Erode(Finder.Erode);

    if Length(TPA) > 0 then
    begin
      ATPA := TPA.Cluster(Finder.ClusterDistance);

      if (Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0) or (Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0) then
      begin
        for I := 0 to High(ATPA) do
        begin
          ATPA[I].Edges().MinAreaRectEx(L, S);

          if ((Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0)) and (not InRange(S, Finder.MinShortSide, Finder.MaxShortSide)) then
            Continue;
          if ((Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0)) and (not InRange(L, Finder.MinLongSide, Finder.MaxLongSide)) then
            Continue;

          Result += ATPA[I];
        end;
      end else
        Result := ATPA;
    end;

    Result.SortBySize();
  end;
end;

(*
Mainscreen.FindObject
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray;

Overload which searches the entire MainScreen.

**Example**

  Debug(MainScreen.FindObject(MyFinder));
*)
function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray; overload;
begin
  Result := Self.FindObject(Finder, Self.Bounds());
end;

var
  MainScreen: TRSMainScreen;

procedure TSRL.Setup; override;
begin
  inherited;

  MainScreen.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  MainScreen.Debug(Bitmap);
end;

