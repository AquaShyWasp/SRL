{$DEFINE SRL_MAINSCREEN_INCLUDED}
{$IFNDEF OSRS}
  {$include_once SRL/osr.simba}
{$ENDIF}

type
  TRSMainScreen = record(TRSInterface)
    UpTextArea: TBox;
    UpTextFilter: TCompareRules;
  end;

var
  MainScreen: TRSMainScreen;

procedure TRSMainScreen.Setup(ClientMode: ERSClientMode);
begin
  Self.Name := 'MainScreen';

  case ClientMode of
    RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM:
      begin
        Self.Alignment.Left := [@RootInterface.X1];
        Self.Alignment.Right := [@RootInterface.X2];
        Self.Alignment.Top := [@RootInterface.Y1];
        Self.Alignment.Bottom := [@RootInterface.Y2];

        Self.UpTextArea := [3, 3, 500, 21];
      end;

    RS_CLIENT_FIXED:
      begin
        Self.Alignment.Left := [@RootInterface.X1, 4];
        Self.Alignment.Right := [@RootInterface.X1, 515];
        Self.Alignment.Top := [@RootInterface.Y1, 4];
        Self.Alignment.Bottom := [@RootInterface.Y1, 337];

        Self.UpTextArea := [7, 7, 500, 25];
      end;
  end;

  Self.UpTextFilter := [-1, 85, True, 85];
end;

function TRSMainScreen.GetUpText(): String;
begin
  Result := OCR.Recognize(Self.UpTextArea, Self.UpTextFilter, RS_FONTSET_BOLD_12_SHADOW);

  {$IFDEF UPTEXT_DEBUG}
  SRL.WriteLn('UpText: ' + Result);
  {$ENDIF}
end;

function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean; overload;

  function IsUpText: Boolean;
  var
    I: Int32;
    UpText: String;
  begin
    UpText := Self.GetUpText();

    for I := 0 to High(Text) do
      if (Text[I] in UpText) or (Text[I] = UpText) then
        Exit(True);
  end;

var
  T: UInt64;
begin
  if (Timeout = -1) then
    T := GetTickCount() + Round(SRL.SkewedRand(100, 85, 250))
  else
    T := GetTickCount() + Timeout;

  repeat
    if IsUpText() then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText() then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= T);
end;

function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean; overload;
begin
  Result := Self.IsUpText([Text], Timeout);
end;

(*
MainScreen.TranslateDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32;

Roughly translates a distance acquired at a specific zoom level to the current zoom level.

**Example:**

.. pascal::

  // 10 pixels at 50 zoom is currently X pixels at our current zoom level.
  WriteLn(MainScreen.TranslateDistance(10, 50));
*)
function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32; forward;
// Implemented in minimaptoms.simba

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox; forward;
// Implemented in minimaptoms.simba

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean; forward;
// Implemented in minimaptoms.simba

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32=0; Accuracy:Double=0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply
done by calling `.ToPoint` on the result.

**Example**

.. pascal::
  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32=0; Accuracy:Double= 0.2): Vector3; forward;
// Implemented in minimaptoms.simba

begin
  SRL.AddSetupMethod(@MainScreen.Setup);
  SRL.AddDebugMethod(@MainScreen.Debug);
end;
