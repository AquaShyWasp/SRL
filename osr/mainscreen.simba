{$DEFINE SRL_MAINSCREEN_INCLUDED}
{$IFNDEF OSRS}
  {$include_once SRL/osr.simba}
{$ENDIF}

type
  TRSObjectFinder = record
    Colors: array of TCTS2Color;
    ColorClusters: array of record Primary, Secondary: TCTS2Color; Distance: Int32;end;
    ClusterDistance: Int32;
    Erode: Int32;
    MinLongSide, MaxLongSide: Int32;
    MinShortSide, MaxShortSide: Int32;
    Zoom: Int32;
  end;

  TRSMainScreen = record(TRSInterface)
    UpTextArea: TBox;
    UpTextFilter: TCompareRules;

    TranslateCache: array[0..100] of array[0..100] of Int32;
  end;

var
  MainScreen: TRSMainScreen;

procedure TRSMainScreen.Setup(ClientMode: ERSClientMode);
var
  I, J: Int32;
begin
  Self.Name := 'MainScreen';

  case ClientMode of
    RS_CLIENT_RESIZABLE_CLASSIC, RS_CLIENT_RESIZABLE_BOTTOM:
      begin
        Self.Alignment.Left := [@RootInterface.X1];
        Self.Alignment.Right := [@RootInterface.X2];
        Self.Alignment.Top := [@RootInterface.Y1];
        Self.Alignment.Bottom := [@RootInterface.Y2];

        Self.UpTextArea := [3, 3, 500, 21];
      end;

    RS_CLIENT_FIXED:
      begin
        Self.Alignment.Left := [@RootInterface.X1, 4];
        Self.Alignment.Right := [@RootInterface.X1, 515];
        Self.Alignment.Top := [@RootInterface.Y1, 4];
        Self.Alignment.Bottom := [@RootInterface.Y1, 337];

        Self.UpTextArea := [7, 7, 500, 25];
      end;
  end;

  Self.UpTextFilter := [-1, 85, True, 85];

  for I := 0 to High(Self.TranslateCache) do
    for J := 0 to High(Self.TranslateCache[I]) do
      Self.TranslateCache[I][J] := -1;
end;

function TRSMainScreen.GetUpText(): String;
begin
  Result := OCR.Recognize(Self.UpTextArea, Self.UpTextFilter, RS_FONTSET_BOLD_12_SHADOW);

  {$IFDEF UPTEXT_DEBUG}
  SRL.WriteLn('UpText: ' + Result);
  {$ENDIF}
end;

function TRSMainScreen.IsUpText(Text: TStringArray; Timeout: Int32 = -1): Boolean; overload;

  function IsUpText: Boolean;
  var
    I: Int32;
    UpText: String;
  begin
    UpText := Self.GetUpText();

    for I := 0 to High(Text) do
      if (Text[I] in UpText) or (Text[I] = UpText) then
        Exit(True);
  end;

var
  T: UInt64;
begin
  if (Timeout = -1) then
    T := GetTickCount() + Round(SRL.SkewedRand(100, 85, 250))
  else
    T := GetTickCount() + Timeout;

  repeat
    if IsUpText() then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText() then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= T);
end;

function TRSMainScreen.IsUpText(Text: String; Timeout: Int32 = -1): Boolean; overload;
begin
  Result := Self.IsUpText([Text], Timeout);
end;

(*
MainScreen.TranslateDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32;

Roughly translates a distance acquired at a specific zoom level to the current zoom level.

**Example:**

.. pascal::

  // 10 pixels at 50 zoom is currently X pixels at our current zoom level.
  WriteLn(MainScreen.TranslateDistance(10, 50));
*)
function TRSMainScreen.TranslateDistance(Dist: Int32; Zoom: Int32): Int32;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetPlayerBox: TBox;

Returns a box surrounding our player. Works at any zoom level.
*)
function TRSMainScreen.GetPlayerBox: TBox;
begin
  // Implemented in minimaptoms.simba
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

Rotates the camera to face point `P`.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;
begin
  // Implemented in minimaptoms.simba
end;

(*
Mainscreen.PointToMM
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;

Takes a mainscreen point and converts it to a point on the minimap.

Returns a Vector3 which includes input height. Conversion to a TPoint if that's what you need is simply
done by calling `.ToPoint` on the result.

**Example**

.. pascal::
  WriteLn Mainscreen.PointToMM(Point(250,140), 2);           // as a vector (more accurate)
  WriteLn Mainscreen.PointToMM(Point(250,140), 2).ToPoint(); // as a TPoint (lost accuracy)
*)
function TRSMainScreen.PointToMM(MS: TPoint; Height: Int32 = 0; Accuracy:Double = 0.2): Vector3;
begin
  // Implemented in minimaptoms.simba
end;

function TRSMainScreen.FindObject(Finder: TRSObjectFinder; Area: TBox): T2DPointArray; overload;
var
  TPA, Primary, Secondary: TPointArray;
  ATPA: T2DPointArray;
  I: Int32;
  L, S: Int32;
begin
  // Translate distances
  Finder.ClusterDistance := Self.TranslateDistance(Finder.ClusterDistance, Finder.Zoom);
  Finder.Erode := Self.TranslateDistance(Finder.Erode, Finder.Zoom);

  for I := 0 to High(Finder.ColorClusters) do
    Finder.ColorClusters[I].Distance := Self.TranslateDistance(Finder.ColorClusters[I].Distance, Finder.Zoom);

  Finder.MinLongSide  := Self.TranslateDistance(Finder.MinLongSide,  Finder.Zoom);
  Finder.MaxLongSide  := Self.TranslateDistance(Finder.MaxLongSide,  Finder.Zoom);
  Finder.MinShortSide := Self.TranslateDistance(Finder.MinShortSide, Finder.Zoom);
  Finder.MaxShortSide := Self.TranslateDistance(Finder.MaxShortSide, Finder.Zoom);

  // Find colors
  for I := 0 to High(Finder.Colors) do
    if SRL.FindColors(TPA, Finder.Colors[I], Area) > 0 then
      ATPA += TPA;

  for I := 0 to High(Finder.ColorClusters) do
  begin
    if (SRL.FindColors(Primary, Finder.ColorClusters[I].Primary, Area) > 0) and
       (SRL.FindColors(Secondary, Finder.ColorClusters[I].Secondary, Area) > 0) then
      ATPA += Primary.PointsInRangeOf(Secondary, 0, Finder.ColorClusters[I].Distance);
  end;

  TPA := ATPA.Merge();

  // Process TPA
  if Length(TPA) > 0 then
  begin
    for 1 to Finder.Erode do
      TPA := ClearTPAFromTPA(TPA, TPA.Edges());

    if Length(TPA) > 0 then
    begin
      ATPA := TPA.Cluster(Finder.ClusterDistance);

      if (Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0) or (Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0) then
      begin
        for I := 0 to High(ATPA) do
        begin
          ATPA[I].MinAreaRectEx(L, S);

          if ((Finder.MinShortSide > 0) or (Finder.MaxShortSide > 0)) and (not InRange(S, Finder.MinShortSide, Finder.MaxShortSide)) then
            Continue;
          if ((Finder.MinLongSide > 0) or (Finder.MaxLongSide > 0)) and (not InRange(L, Finder.MinLongSide, Finder.MaxLongSide)) then
            Continue;

          Result += ATPA[I];
        end;
      end else
        Result := ATPA;
    end;

    Result.SortBySize();
  end;
end;

function TRSMainScreen.FindObject(Finder: TRSObjectFinder): T2DPointArray; overload;
begin
  Result := MainScreen.FindObject(Finder, Self.Bounds());
end;

begin
  SRL.AddSetupMethod(@MainScreen.Setup);
  SRL.AddDebugMethod(@MainScreen.Debug);
end;
